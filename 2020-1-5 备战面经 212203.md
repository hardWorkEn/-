备战面经

## 设计模式

+ 单例模式

  ```
  特点：
  类构造器私有
  持有自己类型的属性
  对外提供获取实例的静态方法
  ```

  + 懒汉、恶汉、双重校验锁、静态内部类

  ```java
  懒汉：线程不安全，延迟初始化
  public class Singleton{
  	private static Singleton instance;
  	private Singleton(){}
      public static Singleton getInstance(){
     		if(instance == null){
     			instance = new SingleTon();
     		}
    		return instance; 		
      }
  }
  饿汉：线程安全，比较常用，容易产生垃圾，因为一开始就初始化
  public class Singleton{
  	private Singleton(){}
  	private static Singleton instance = new Singleton();
      public static Singleton getInstance(){
      	return instance;
      }
  }
  双重锁模式：线程安全，延迟加载，能在多线程情况下保持高性能
  public class Singleton{
  	private volatile static Singleton instance;
  	private Singleton(){}
      public static Singleton getInstance(){
      	if(instance == null){
          	synchronized(Singleton.class){
              	if(instance == null){
              		instance = new Singleton();
              	}	
         		}
      	}
          return instance;
      }
  }
  静态内部类
  public class Singleton{
  	private Singleton(){}
      public static Singleton getInstance(){
      	return Inner.instance;
      }
      private static class Inner{
      	private static final Singleton instance = new Singleton();
      }
  }
  ```

+ 工厂模式


## JAVA基础

+ 抽象类和接口区别

  ```
  不同点：
  1、抽象类中可以定义构造函数，接口不能定义构造函数；
  2、抽象类中可以有抽象方法和具体方法，而接口中只能有抽象方法（public abstract）；
  3、抽象类中的成员权限可以是 public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstrat、成员变量默认：public static final）；
  在 Java8 中，允许在接口中包含带有具体实现的方法，使用 default 修饰，这类方法就是默认方法。
  4、抽象类中可以包含静态方法，而接口中不可以包含静态方法；抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能包含静态方法，JDK1.8 以后可以包含。之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包含了，只能直接用接口调用静态方法。1.8 仍然不可以包含静态代码块。接口的成员变量默认是 public static final，static 是为了保证变量只有一份，因为一个类可以实现多个接口，定义为 static 后，如果出现重名，那么存储在静态存储区的时候就会报错，因为静态存储区已经有一份了，你改名吧（成员变量可以通过接口和实现接口的类来调用）。final 是因为接口的东西是大家共用的，不能随便修改。
  相同点：
  1、都不能被实例化；
  2、可以将抽象类和接口作为引用类型；
  3、一个类如何继承了某个抽象类或者实现了某个接口，就必须对其中所有的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。
  ```

+ 集合类的结构
  
+ Iterator、Collection（List、Set、Queue）、Map
  
+ forward和redirect的区别？

```
转发：
转发是发生在服务器的，是由服务器进行跳转的。细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问 Servlet111 的时候，即使跳转到了Servlet222 的页面，浏览器的地址还是 Servlet111 的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。实现转发只是一次的 http 请求，一次转发中request和 response 对象都是同一个。这也解释了，为什么可以使用 request 作为域对象进行Servlet 之间的通讯。
重定向：
重定向是发生在浏览器上的。重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。实现重定向的原理是由 response 的状态码和 Location头组合而实现的。这时由浏览器进行的页面跳转实现重定向会发出两个 http 请求，request 域对象是无效的，因为它不是同一个 request 对象
转发和重定向的区别：
1、能够去往的 URL 的范围不一样：转发是服务器跳转，只能去往当前 web 应用的资源。而重定向是浏览器跳转，可以去往任何的资源
2、传递数据的类型不一样：转发的 request 对象可以传递各种类型的数据，包括对象。而重定向只能传递字符串
3、跳转的时间不同：转发时，执行到跳转语句时就会立刻跳转。而重定向时，整个页面执行完之后才执行跳转。
```

+ Array List和Linked List的区别

  ```
  ArrayList 底层实现就是数组，且ArrayList实现了RandomAccess，表示它能快速随机访问存储的元素，通过下标 index 访问，只是我们需要用 get() 方法的形式， 数组支持随机访问， 查询速度快， 增删元素慢；
  LinkedList 底层实现是链表， LinkedList 没有实现 RandomAccess 接口，链表支持顺序访问， 查询速度慢，增删元素快
  两者都是线程不安全的
  ```

+ List和Set区别

  ```
  list可以允许重复的对象，set不允许重复对象
  list可以插入多个null对象，set只允许插入一个null元素
  list有序，保证了每个元素的插入顺序，set是无序的
  ```

+ 重写equal为什么要重写hash code

  ```
  https://www.jianshu.com/p/75d9c2c3d0c1
  ```

+ GET和POST区别

  ```java
  1.GET在浏览器回退时是无害的，而POST会再次提交请求
  2.GET产生的URL地址可以被Bookmark,而POST不可以
  3.GET请求会被浏览器主动cache，而POST不会
  4.GET请求只能进行url编码，而POST可以支持多种编码方式
  5.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
  6.GET请求在URL中有长度限制，而POST没有
  7.GET只接受ASCII字符，而POST没有限制
  8.GET比POST更不安全，参数直接暴露在URL中，不能传递敏感信息
  9.GET参数通过URL传递，POST放在request body中
  ```

+ String的底层原理

  ```
  底层是一个不可变字符串，是一个char类型的数组，使用连接符的时候，实际上是经过了StringBuilder的优化处理的，并不是在原来的String对象中做追加。
  ```

##  Hash Map

+ 底层结构
  + 数组+链表
+ Put的过程
+ 为什么长度是2的倍数
  + 找索引时key的hash值与数组的长度值减1进行运算，长度为2的倍数时能减少碰撞
+ JDK1.7和1.8中Hash Map的区别
  + 1.8增加红黑树、头插变为尾插、扩容后元素位置要么在原位置，要么在原位置+扩容前旧容量
+ 为什么线程不安全
  + 扩容时链表可能形成闭环
+ ConcurrentHashMap怎么保证线程安全
+ ConcurrentHashMap和HashMap的区别
+ HashMap的原理，用红黑树解决了什么问题
+ hash冲撞怎么办？如何rehash
+ HashMap的遍历方式
+ volatile和synchronized的区别

```
1、volatile 本质是在告诉 Jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2、volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。
3、volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
4、volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
5、volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。
```

+ Synchronized和Lock的区别
+ Lock底层实现
+ Atomic原理

```
Atomic 包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。
Atomic 系列的类中的核心方法都会调用 unsafe 类中的几个本地方法。我们需要先知道一个东西就是 Unsafe 类，全名为：sun.misc.Unsafe，这个类包含了大量的对 C 代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过 unsafe 分配内存的时候，如果自己指定某些区域可能会导致一些类似 C++ 一样的指针越界到其他进程的问题。
```

+ volatile怎么保证可见性

```
首先Java内存模型分为，主内存、工作内存。
```

+ synchronized的原理

```
synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
```

+ sleep()和wait()的区别？

```
sleep()方法将正在执行的线程主动让出CPU，在sleep指定时间后CPU在回到该线程继续往下执行（只让出了CPU，并不会释放同步锁）;wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源而进行。
sleep()方法可以在任何地方用，而wait()方法则只能在同步方法或同步块中使用
sleep()是线程类的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间恢复，wait()是Object的方法，调用会放弃对象锁，进入等待队列。
```

+ 自旋锁的好处
+ HashMap如何扩容，为什么长度是2的幂次

```
为了能让HashMap减少碰撞，分配均匀，
```

+ HashMap初始化默认长度，初始化长度为7会怎么样

+ HashMap在1.8有什么改进

+ HashMap什么时候转红黑树

+ 为什么8转红黑树，6退化为链表

+ HashMap为什么线程不安全

+ ConcurrentHashMap为什么线程安全

+ ConcurrentHashMap锁分段在1.8怎么实现

+ ThreadLocal的作用

+ HashMap和HashSet的区别

  + 如果你看过 `HashSet` 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 `clone() `、`writeObject()`、`readObject()`是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。

  |         HashMap          |                        HashSet                         |
  | :----------------------: | :----------------------------------------------------: |
  |      实现了Map接口       |                     实现了Set接口                      |
  |        存储键值对        |                        存储对象                        |
  | 调用put()向map中添加元素 |                调用add()想Set中添加元素                |
  |   使用键来计算HashCode   | 使用对象来计算HashCode值，使用equals()判断对象的相等性 |

+ HashMap和HashTable的区别

```
1.线程是否安全：HashMap是非线程安全的，HashTable是线程安全的，内部的方法都经过synchronized修饰
2.效率：因为线程安全的问题，HashMap比HashTable效率高一点
3.对Null Key和Null Value的支持：HashMap中null可以作为键和值，只能有一个键，HashTable中只要put进一个null键，直接抛出NullPointerException
4.初始容量和扩容容量的大小：创建时不指定容量初始值，HashMap默认的初始大小为11，之后每次扩容，容量变为原来的2n+1。HashMap默认的初始化大小为16，每次扩容为之前的2倍。创建时给定初始值，HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。
5.底层数据结构：JDK1.8之后HashMap当链表长度大于等于8时，将链表转化为红黑树。
```

+ ArrayList扩容机制

```

```

+ ArrayList与LinkedList区别

```java
1.是否线程安全：两者都是线程不安全的
2.底层数据结构：ArrayList底层使用的是object数组，LinkedList底层使用的双向链表数据结构
3.插入和删除是否受元素位置影响：①ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响，②LinkedList采用链表存储，所以不受元素位置的影响。
4.是否支持随机快速访问：LinkedList不支持高效的随机元素访问，ArrayList支持。
5.内存空间占用：ArrayList的空间浪费主要是体现在List的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在他的每一个元素都需要消耗比ArrayList更多的空间（要存放直接后继和直接前驱以及数据）
```

## 线程池

+ 线程池常用参数
  + 核心线程数，最大线程数，阻塞队列，线程最大存活时间

```
corePoolSize:核心线程数，当有任务进来的时候，如果当前线程还未达到corePoolSize个数，则创建核心线程，核心线程有几个特点：
一：当线程数未达到核心线程最大值的时候，新任务进来，即使有空闲线程，也不会复用，仍然新建核心线程。
二：核心线程一般不会被销毁，即使是空闲的状态，如果通过方法allowCoreThreadTimeOut(boolean value)设置为true时，超时也同样会被销毁。
三：生产环境首次初始化的时候，可以调用prestartCoreThread()方法来预先创建所有核心线程，避免第一次调用缓慢。
maximumPoolSize:除了有核心线程外，有些策略是当核心线程完全无空闲的时候，还会创建一些临时的线程来处理任务，maximumPoolSize 就是核心线程 + 临时线程的最大上限。临时线程有一个超时机制，超过了设置的空闲时间没有事儿干，就会被销毁
keepAliveTime:超时时间，也就是最大空闲时间，默认用于非核心线程。
unit:超时的时间单位
workQueue:等待执行的任务队列，如果核心线程没有空闲的了，新来的任务就会被放到这个等待队列。
ThreadFactory:是一个接口，用于实现生成线程的方式，可以用Executors.defaultThreadFactory()默认的实现
handle:当没有空闲的线程处理任务，并且等待队列已满（对有界队列有效），再有新任务进来的话，就要做一些取舍了。
一：ThreadPoolExecutor.AbortPolicy:直接抛出异常，这是默认策略。
二：ThreadPoolExecutor.DiscardPolicy:直接丢弃任务，不抛出异常。
三：ThreadPoolExecutor.DiscardOldPolicy:直接丢弃等待时间最久的任务，然后将新任务加入队列
四：ThreadPoolExecutor.CallerRunsPolicy:由线程池所在的线程处理该任务。
```

+ 线程池工作流程

```
1.如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务
2.如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
3.如果队列满了，而且正在运行的线程数量小于maximumPoolSize，那么创建非核心线程运行这个任务
4.如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么执行拒绝策略
当一个线程完成任务时，会从队列中取下一个任务来执行。
当一个线程无事可做，超过一定时间（KeepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么非核心线程会被回收，当所有任务完成后，线程池会收缩到corePoolSize的大小。
```

+ 线程池的类别和区别

  ```
  newCachedThreadPool:
      一：重用之前的线程
      二：适合执行许多短期异步任务的程序
      三：调用execute()将重用以前构造的线程
      四：如果没有可用的线程，则创建一个新线程并添加到池中
      五：默认为60s未使用就被终止和移除
      六：长期闲置的池将不会消耗资源
  newWorkStealingPool:
  	一：获取当前可用的线程数量进行创建作为并行级别
  	二：使用ForkJoinPool
  newSingleThreadPool:
  	一：任何情况下都不会有超过一个任务处于活动状态
  	二：能保证执行顺序，先提交的先执行
  	三：当线程执行中出现异常，创建一个新的线程替换之
  newFixedThreadPool:
  	一：创建固定数量的线程池
  	二：当所有线程都处于活动状态时，如果提交了其他任务，将会在队列中等待一个线程可用
  	三：线程会一直存在，直到调用shutdown
  newScheduledThreadPool:
  	一：设定延迟时间，定期执行
  	二：空闲线程会进行保留
  	
  submit()：提交一个线程任务，可以接受回调函数的返回值
  execute():执行一个任务，没有返回值
  shutdown():表示不再接受新任务，但不会强行终止已经提交或者正在执行中的任务
  shutdownNow():对于尚未执行的任务全部取消，正在执行的任务全部发出interrupt()，停止执行。
  ```

+ 阻塞队列的类别和区别

```
https://www.jianshu.com/p/9e4eca73553c
```

## JVM

+ 内存结构和各自存放的内容
  + 方法区、堆、虚拟机栈、本地方法栈、程序计数器

```
程序计数器：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
虚拟机栈：描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
本地方法栈：与虚拟机栈的作用类似，只不过本地方法栈执行的是本地方法。
堆：是被所有线程所共享的一块内存区域，在虚拟机启动时创建，几乎所有的对象都在这里分配内存。
方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
```

+ 新生代和老年代的垃圾回收算法
  + 新生代->复制、老年代->标记-整理（CMS用的标记-清除）
+ CMS/G1的流程
  + 初始标记->并发标记->重新标记->并发清除

```
CMS:
初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，需要暂停所有的工作线程。
并发标记：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程
```



+ CMS/G1的特点和区别
  + CMS：尽可能的减少停顿时间，采用标记-清除，会造成内存碎片化
  + G1：可以预测停顿时间，采用标记-整理，减少内存碎片化，将内存划分为region粒度
+ 判断垃圾是否可以回收的方法
  + 引用计数法、可达性分析算法
+ 哪些对象可以作为GCRoots

```
虚拟机栈中引用的对象
本地方法栈中Native引用的对象
方法区中常量引用的对象
方法区中类静态属性引用的对象
```

+ OOM可能是什么原因导致的
+ 并发控制可以用哪些方式实现
+ 线程池的大小该如何设置
+ 堆和栈的区别
+ 递归调用是在堆上还是栈上

## Spring

+ IOC和AOP的含义和原理
+ Spring、Springboot、Springmvc的区别
+ Springboot的启动流程
+ Spring用到了哪些设计模式

```
1、工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象
2、代理设计模式 : Spring AOP 功能的实现
3、单例设计模式 : Spring 中的 Bean 默认都是单例的
4、模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式
5、包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源
6、观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用
7、适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配 Controller
```

+ Bean的生命周期

```
1、Spring 启动，查找并加载需要被 Spring 管理的 Bean，进行 Bean 的实例化；
2、Bean 实例化后，对 Bean 的引入和值注入到 Bean 的属性中；
3、如果 Bean 实现了 BeanNameAware 接口的话，Spring 将 Bean 的 Id 传递给 setBeanName() 方法；
4、如果 Bean 实现了 BeanFactoryAware 接口的话，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入；
5、如果 Bean 实现了 ApplicationContextAware 接口的话，Spring 将调用 Bean 的 setApplicationContext() 方法，将 Bean 所在应用上下文引用传入进来；
6、如果 Bean 实现了 BeanPostProcessor 接口，Spring 就将调用它们的 postProcessBeforeInitialization() 方法；
7、如果 Bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet() 方法。类似地，如果 Bean 使用 init-method 声明了初始化
方法，该方法也会被调用；
8、如果 Bean 实现了 BeanPostProcessor 接口，Spring 就将调用它们的postProcessAfterInitialization() 方法；
9、此时，Bean 已经准备就绪，可以被应用程序使用了。它们将一直驻留在应用上下文中，直到应用上下文被销毁；
10、如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destory() 接口方法，同样，如果 Bean 使用了 destory-method 声明销毁方法，该方法也会被调用。
```

+ Springmvc的流程

```
客户端发送请求->前端控制器DispatcherServlet接收客户端请求->找到处理器映射HandleMapping解析请求对应的Handler->HandlerAdapter会根据Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑->处理器返回一个模型视图ModelAndView->视图解析器进行解析->返回一个视图对象->前端控制器DispatcherServlet渲染数据->将得到视图对象返回给用户
```

+ Springboot的优势

## MySQL

### 事务

+ 什么是事务

```
事务就是一组独立不可分割的工作单元，事务的操作要么全部执行，要么都不执行。
```

+ 事务的特性（ACID），详细说明各个特性的含义
  + 原子性、一致性、隔离性、持久性

```
原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部不执行。
一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。
隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
持久性：一个事务被提交之后，他对数据库数据的改变是持久的，即便数据库发生故障也不应该对其有任何影响。
```

+ 事务隔离级别
  + 未提交读、已提交读、可重复读、串行化

```
READ-UNCOMMITTED(未提交读)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读。
READ-COMMITTED(已提交读)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读和不可重复读仍有可能发生。
REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是相同的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读，不可重复读以及幻读。
```

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| READ-UNCOMMITTED |  √   |     √      |  √   |
|  READ-COMMITTED  |  ×   |     √      |  √   |
| REPEATABLE-READ  |  ×   |     ×      |  √   |
|   SERIALIZABLE   |  ×   |     ×      |  ×   |

+ 脏读、不可重复读、幻读的区别

```
脏读(Dirty read)：当一个事务正在访问数据并对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。
丢失修改(Lost to modify)：指在一个事务读取一个数据时，另外一个事务也访问了这个数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务的修改结果就会丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取到A=20，事务1修改A=19，事务2也修改A=18，最终结果A=18，事务1的修改被丢失。
不可重复读(Unrepeatableread)：指在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也访问了该数据，那么在第一次事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
幻读(Phantom read)：幻读和不可重复读类似，他发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据，在随后的查询中，第一个事务就会发现一些原本不存在的记录。
```

> 不可重复读和幻读区别：不可重复读的重点是修改，比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除，比如多次读取一条记录发现记录增多或减少了。

+ Innodb和Mysiam索引区别

```
一、InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的。
InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。
InnoDB是聚簇索引，数据在索引之下。
二、MyISAM使用的是表锁，InnoDB使用行锁
三、MyISAM不支持事务和MVCC，InnoDB支持事务和MVCC
四、MyISAM支持FULLTEXT类型的全文索引，InnoDB不支持FULLTEXT类型的全文索引
五、MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址，InnoDB如果没有设定主键或非空唯一索引，就会生成一个6字节的主键，数据是主索引的一部分，辅助索引保存的是主索引的值。
六、MyISAM不支持外键，InnoDB支持外键。
```

+ left join,right join区别

```
left join在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录
right join在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录
```

+ 了解SQL注入吗
+ 从服务端如何防止SQL注入

```

```

+ 数据库如何加行级锁
+ 慢查询SQL怎么排查

### 索引

+ 常用索引（B树、Hash）
+ 聚簇索引和非聚簇索引的区别

```

```



+ 联合索引和单个索引的区别，联合索引的最左匹配原则
+ B树和B+树的区别
  + B+树的非叶子节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”
  + B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，因此B+树查找更稳定
  + 对于范围查找来说，B+树只要遍历叶子节点链表即可，B树却要重复地中序遍历
+ B+数的原理和优势
+  数据库索引的原理
+ mysql的回表
+ mysql优化
+ 线程池原理
+ 线程池参数怎么配置

## Redis

+ Redis的五种数据结构
  + String、Hash、List、Set、Zset
+ Redis为什么快
  + 内存，单线程，IO多路复用
+ Redis持久化
  + RDB、AOF
+ Redis高可用
  + 哨兵机制、Redis Cluster、持久化
+ zset的底层原理

## 计算机网络

+ 点击一个URL到页面返回，发生了什么
  + 客户端传给服务端时经过TCP/IP四层模型，中途依次加入HTTP报文、TCP报文、IP报文、MAC报文，然后逆序依次拆包

```
浏览器向DNS服务器查找输入URL对应的IP地址
DNS服务器返回网站的IP地址
浏览器根据IP地址与目标web服务器在80端口上建立了TCP连接
浏览器获取请求页面的HTML代码
浏览器在显示窗口内渲染HTML
窗口关闭时，浏览器终止与服务器的链接
```

```
DNS解析：浏览器查询DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询。
TCP连接：浏览器获取域名对应的IP地址以后，浏览器向服务器请求建立连接，发起三次握手。
发送HTTP请求：TCP连接建立起来后，浏览器向服务器发送HTTP请求。
服务器处理请求并返回HTTP报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器
浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤向服务器请求这些资源，浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。
连接结束。
```

+ OSI七层模型&TCP/IP四层模型
+ HTTP1.0与HTTP1.1的主要变化

> 1、http1.0在不断改进，首先提出了长连接，可以在一次tcp连接中不断发送请求。
>
> 2、http1.1支持只发送header而不发送body，原因是先用header判断能否成功，在发数据，节约带宽。
>
> 3、http1.1的host字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到host

+ HTTP1.0和HTTP2.0的主要变化

> 1、HTTP2.0支持多路复用，同一个连接可以并发处理多个请求，方法是把http数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个http请求顺序到达
>
> 2、HTTP2.0支持服务端推送，就是服务端在HTTP请求到达后，除了返回数据之外，还推送了额外的内容给客户端。
>
> 3、HTTP2.0压缩了请求头
>
> 4、HTTP2.0适用于https场景，因为在http和tcp中间加了一层ssl层

+ Cookie和Session的区别

```
一、存储位置不同
cookie的数据存储在浏览器中，session的数据信息存储在服务器上。
二、存储容量不同
单个cookie保存的数据小于等于4KB，一个站点最多保存20个cookie，session没有上限，出于对服务器端的性能考虑，session内不要存放过多的东西。
三、存储方式不同
cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。
session中能够存储任何类型的数据
四、隐私策略不同
cookie对客户端是可见的，可以分析存放在本地的cookie进行cookie欺骗，是不安全的。
session存储在服务器上，对客户端是透明的，不存在泄漏的风险
五、跨域支持上的不同
cookie支持跨域
session不支持跨域
```

+ HTTP如何保持长连接

```
在HTTP/1.0中默认使用短连接，也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束后就中断连接，而从HTTP/1.1起，默认使用长连接，用以保持连接特性，使用长连接的HTTP协议会在响应头加入Connection:keep-alive这行代码，keep-alive不会永久保持连接，有一个保持时间，可以在不同服务器中设置，需要客户端和服务器都支持长连接才能实现长连接。
```

### TCP & UDP

+ TCP三次握手，四次挥手的流程（最好能画图，说明各阶段状态）

![http3](https://user-gold-cdn.xitu.io/2019/6/22/16b7e57d8540d1e4?imageView2/0/w/1280/h/960/ignore-error/1)

```

```

+ 为什么需要三次握手
  
  + 防止已过期的链接再次传到被连接的主机
  
  ```
  第一次握手：建立连接时，客户端发送SYN包到服务器
  第二次握手：服务器收到SYN包，向客户端发送ACK包，同时发送一个自己的SYN包
  第三次握手：客户端收到服务器的SYN+ACK包，想服务器发送确认包ACK
  ```
  
+ 为什么需要四次挥手，断开连接时为什么比建立连接多一次
  
  + 服务端的ACK和FIN一般都会分开发送，ACK表示自己收到了客户端的断开请求（但还有数据没传输完），FIN表示自己传输完了数据
  
  ```
  这是由于TCP的半关闭造成的，因为TCP连接是全双工的（即数据可在两个方向上同时传递），所以进行关闭时每个方向上都要单独进行关闭，这个单方向的关闭就叫半关闭，当一方完成它的数据发送任务，就发送一个FIN来向另一方通知要终止这个方向的链接。
  1、关闭客户端到服务端的连接：首先客户端A发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。
  2、服务器收到这个FIN，他返回一个ACK，确认号ack为收到的序号加1
  3、关闭服务器到客户端的链接，也是发送一个FIN给客户端
  4、客户端收到FIN后，发回一个ACK报文确认，并将确认序号seq设置为收到序号+1
  ```
  
+ TCP 和UDP的区别

```
UDP在传送数据之前不需要先建立连接，远程主机在收到UDP报文后，不需要给出任何确认。

```

|      |              |            |            |          |          |                  |          |
| :--: | :----------: | :--------: | :--------: | :------: | :------: | :--------------: | -------- |
|      | 是否面向连接 | 传输可靠性 |  传输形式  | 传输效率 | 所需资源 |     应用场景     | 首部字节 |
| TCP  |   面向连接   |    可靠    |   字节流   |    慢    |    多    | 要求通信数据可靠 | 20-60    |
| UDP  |    无连接    |   不可靠   | 数据报文段 |    快    |    少    |  要求通信速度高  | 8个字节  |

+ TIME_WAIT的作用
  + 保证客户端发送的最后一个ACK报文能够到达服务器
  + 防止类似与三次握手中提到了的已经失效的连接请求报文段出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。
+ TCP协议如何保证可靠性传输

```
数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送端超时会重发数据。
对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序，TCP将对失序数据进行重新排序，然后才交给应用层。
丢弃重复数据：对于重复数据，能够丢弃重复数据
应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之1秒
超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段。
流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，TCP使用的流量控制协议是可变大小的滑动窗口协议。
```

### HTTPS

+ HTTPS的优势
  
  + CA证书认证、加密传输
  
  ```
  优点：
  1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
  2、HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要 比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
  3、HTTPS 是现行架构下安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人 攻击的成本。
  缺点：
  1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；
  2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会 因此而受到影响；
  3、SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会 用；
  4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个 消耗；
  5、HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面 几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可 以控制 CA 根证书的情况下，中间人攻击一样可行。
  ```
  
+ HTTP与HTTPS的区别

```
1、开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；
2、资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；
3、端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者 是 80，后者是 443；
4、安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的 可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
```

+ HTTPS建立数据流程

```
1、客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；
2、服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形 式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；
3、客户端收到网站的证书之后要做下面的事情：
（1）验证证书的合法性；
（2）如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；
（3）用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给 服务器。
4、服务器接收到客户端传送来的信息，要做下面的事情：
（1）用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；
（2）使用密钥加密消息；
5、如果计算法 hash 值一致，握手成功。
https 要知道的几个加密算法：
握手的时候使用的非对称加密算法：用来加密握手之后的请求和应答；
传输信息的时候使用的对称加密；
保证数据的完整性用的是 hash 算法（数字签名）
番外：关于公钥加密私钥解密与私钥加密公钥解密说明
第一种是签名，使用私钥加密，公钥解密，用于让所有公钥所有者验证私钥所有者的 身份并且用来防止私钥所有者发布的内容被篡改。但是不用来保证内容不被他人获得。
第二种是加密，用公钥加密，私钥解密，用于向公钥所有者发布信息，这个信息可能 被他人篡改，但是无法被他人获得。
```

+ 为什么传输过程中采用对称加密，协商时采用非对称加密
  
  + 对称加密快
  
  ```
  对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的大问题就是密钥发送问题，即如何安全地将密钥发给对方。
  非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。
  由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。
  ```
  
  

## 操作系统

### 进程 & 线程

+ 进程和线程的区别

```
进程：是系统进行资源分配和调度的一个独立单位，是最小的资源管理单位
线程：是进程的一个实体，是CPU调度和分派的基本单位，是最小的CPU执行单元。
```

+ 进程间通信方式
  + 管道、命名管道、消息队列、信号量、信号、共享内存、套接字
+ 线程间通信方式
  + 消息队列、全局变量

## Linux

+ 查找某个进程（ps aux |grep threadId）
+ 杀掉某个进程（kill,参数添加-9表示强制执行）
+ 查看某个端口是否被占用（netstat -anp|grep threadId）
+ 实时查看进程状态（top）

## 算法

+ 最大子序列
+ 反转链表
+ 数组中查找两数之和为k的序列对
+ 二分查找
+ 求二叉树中左叶子节点的总和
+ 从1亿个数找出前10
+ 

## 消息队列

+ rabbitmq和kafka的区别
+ rabbitmq如何保证事务
+ 消息队列的优势

## 分布式

+ 分布式缓存redis原理，zookeeper锁是如何实现的
+ 分布式缓存读写不一致的问题
+ 数据库调优
+ dubbo原理
+ 分布式缓存锁的实现
+ mysql分库分表原则





# 总结

+ 分布式必须了解，redis,dubbo,kafka
+ 数据库调优，组合索引和原理，事务
+ 并发，容器
+ spring aop ioc，mybatis
+ 算法
+ redis
+ 计算机网络
+ 项目

------

## 腾讯-医疗

### 一面

#### MySQL

+ 事务的特性
+ 如何删除表中的所有数据，delete和truncate的区别
+ char,varchar,text的区别
+ 一张表里数据量大，慢查询怎么办

#### Redis

+ redis的数据结构
+ zset的底层结构
+ redis的常用命令

#### 计算机网络

+ UDP如何重组数据
+ 应用层和网络层的作用
+ ARP是网络层的吗
+ TCP和UDP的报文头内容
+ HTTP
  + HTTP属于TCP还是UDP
  + HTTP1.1比1.0多了什么
  + HTTP Request Header中有哪些 内容
  + 如何判断是否是长连接
+ DNS属于TCP还是UDP，原理
+ Ping使用的什么协议，原理



------

------

#### 2019年10月30日		

#### 继承中变量的访问特点

在子类方法中访问一个变量

- 子类局部范围找
- 子类成员范围找
- 父类成员范围找
- 如果都没有就报错（不考虑父亲的父亲）

#### 继承中构造方法的访问特点

子类中所有的构造方法默认都会访问父类中无参的构造方法

- 因为子类会继承父类中的数据，可能还会使用父类中的数据。所以，子类初始化之前，一定要先完成父类数据的初始化
- 每一个子类构造方法的第一条语句默认都是：super()

如果父类中没有无参构造方法，只有带参构造方法，该怎么办？

- 通过使用super关键字去显示地调用父类中的带参构造方法
- 在父类中自己提供一个无参构造方法。

#### 继承中成员方法的访问特点

通过子类对象访问一个方法

- 子类成员范围找
- 父类成员范围找
- 如果都没有就报错（不考虑父亲的父亲）

#### 方法重写注意事项

- 私有方法不能被重写（父类私有成员子类是不能被继承的）
- 子类访问权限不能低于父类（public>默认>私有）

#### 自动建包

编译：**javac -d . HelloWorld.java**

运行：**java com.itheima.HelloWorld**

#### 权限修饰符

|  修饰符   | 同一个类中 | 同一个包中 | 不同包的子类 | 不同包的无关类 |
| :-------: | :--------: | :--------: | :----------: | :------------: |
|  private  |     √      |            |              |                |
|   默认    |     √      |     √      |              |                |
| protected |     √      |     √      |      √       |                |
|  public   |     √      |     √      |      √       |       √        |

#### final关键字

- 修饰方法：表明该方法是最终方法，不能被重写
- 修饰变量：表明该变量是常量，不能再次被赋值
- 修饰类：表明该类时最终类，不能被继承

#### final修饰局部变量

- 变量是基本类型：final修饰指的是基本类型的数据值不能改变
- 变量是引用类型：final修饰指的是引用类型的地址值不能改变，但是地址里面的内容是可以发生改变的。

#### static关键字

- 被类的所有对象共享
- 可以被类名调用

#### static访问特点

非静态的成员方法

- 能访问静态的成员变量
- 能访问非静态的成员变量
- 能访问静态的成员方法
- 能访问非静态的成员方法

静态的成员方法

- 能访问静态的成员变量
- 能访问静态的成员方法

**总结：静态成员方法只能访问静态成员。**

#### 多态中成员访问特点

- 成员变量：编译看左边，执行看左边
- 成员方法：编译看左边，执行看右边

为什么成员变量和成员方法的访问不一样呢？

- 因为成员方法有重写，而成员变量没有

#### 抽象类的成员特点

- 成员变量

  可以是变量也可以是常量

- 构造方法

  有构造方法，但是不能实例化

- 成员方法

  可以有抽象方法，限定子类必须完成某些动作

  也可以有非抽象方法，提高代码复用性

#### 接口的成员特点

- 成员变量：只能是常量，默认修饰符：public static final
- 构造方法：接口中没有构造方法
- 成员方法：只能是抽象方法，默认修饰符：public abstract

#### 抽象类与接口的区别

- 成员区别：
  - 抽象类：变量，常量，构造方法，抽象方法，非抽象方法
  - 接口：常量，抽象方法
- 关系区别：
  - 类与类：继承，单继承
  - 类与接口：实现，可以单实现，可以多实现
  - 接口与接口：继承，单继承，多继承

#### 内部类的访问特点

- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须创建对象

#### 成员内部类

- 在类的成员位置：成员内部类
- 在类的局部位置，局部内部类

成员内部类，外界如何创建对象使用呢？

- 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象
- 范例：Outer.Inner oi = new Outer().new Inner();

#### 局部内部类

```
局部内部类是在方法中定义的类，所以外界是无法直接使用的，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量。
```

#### int与String相互转换

- **int转换为String**
  - public static String valueOf(int i)：返回int参数的字符串形式。该方法是String类中的方法
- **String转换为int**
  - public static int parseInt(String s)：将字符串解析为int类型，该方法是Integer类中的方法

#### 异常体系

![1572435414874](C:\Users\RYQBDYQ\AppData\Local\Temp\1572435414874.png)

#### throws和throw区别

**throws**

- 用在方法后面，跟的是异常类名
- 表示抛出异常，由方法的调用者处理
- 表示出现异常的一种可能性，并不一定会发生异常

**throw**

- 用在方法体内，跟的是异常对象名
- 表示抛出异常，由方法体内的语句处理
- 执行throw一定抛出了某种异常

------

#### 2019年10月31号

#### 进程

- 进程是正在运行的程序，是系统进行资源分配和调用的独立单位。
- 每一个进程都有它自己的内存空间和系统资源。

#### 线程

- 是进程中的单个顺序控制流，是一条执行路径
- 单线程：一个进程如果只有一条执行路径，称为单线程程序
- 多线程：一个进程如果有多条执行路径，称为多线程程序

#### 多线程的实现方式

方式1：继承Thread类

- 定义一个类MyThread继承Thread类

- 在MyThread类中重写run()方法

- 创建MyThread类中的对象

- 启动线程

  - 两个小问题：

    - 为什么要重写run()方法？

      因为run()是用来封装被线程执行的代码

    - run()方法和start()方法的区别？

      run()：封装线程执行的代码，直接调用，相当于普通方法的调用

      start()：启动线程，然后由JVM调用此线程的run()方法

#### 网络编程三要素

**IP地址**

- 要想让网络中的计算机能够相互通信，必须为每一台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识

**端口**

- 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了，也就是应用程序的标识。

**协议**

- 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样，在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式，传输速率，传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换，常见的协议有UDP和TCP协议。

常用命令：

- ipconfig：查看本机IP地址
- ping IP地址：检查网络是否连通

特殊IP地址：

- 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用

#### InetAddress的使用

InetAddress：此类表示Internet协议地址

|                  方法名                   |                             说明                             |
| :---------------------------------------: | :----------------------------------------------------------: |
| static InetAddress getByName(String host) | 确定主机名称的IP地址，主机名称可以是机器名称，也可以是IP地址 |
|           String getHostName()            |                     获取此IP地址的主机名                     |
|          String getHostAddress()          |                 返回文本显示中的IP地址字符串                 |

协议：计算机网络中，连接和通信的规则被称为网络通信协议。

**UDP协议**

- 用户数据报协议（User Datagram Protocol）
- UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接，简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源较小，通信效率高，所以通常都会用于音频、视频和普通数据的传输，**在传输重要数据时不建议使用UDP协议**。

**TCP协议**

- 传输控制协议（Transmission Control Protocol）
- TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后在传输数据，它提供了两台计算机之间可靠无差错的数据传输，在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”
- 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠
  - 第一次握手，客户端向服务器端发出连接请求，等待服务器确认
  - 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求
  - 第三次握手，客户端再次向服务器端发送确认信息，确认连接
- 完成三次握手，连接建立后，客户端与服务器就可以开始进行数据传输了，由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛

#### UDP发送数据

1. 创建发送端的Socket对象（DatagramSocket）DatagramSocket()

   ```
   DatagramSocket ds = new DatagramSocket();
   ```

2. 创建数据，并把数据打包 DatagramPacket(byte[] bys,int length,InetAddress address,int port)

   ```
   byte[] bys = "hello,world".getBytes();
   int length = bys.length;
   InetAddress addr = InetAddress.getByName("172.17.24.101");
   int port = 10000;
   DatagramPacket dp = new DatagramPacket(bys,length, addr, port);
   ```

3. 调用DatagramSocket对象的方法发送数据 void send(DatagramPacket p)

   ```
   ds.send(dp);
   ```

4. 关闭发送端 void close()

   ```
   ds.close();
   ```

#### UDP接收数据

1. 创建接收端的Socket对象（DatagramSocket）

   DatagramSocket(int port)

   ```java
   DatagramSocket ds = new DatagramSocket(10000);
   ```

2. 创建一个数据包，用于接收数据

   DatagramPacket(byte[] buf,int length)

   ```java
   byte [] data = new byte[1024];
   DatagramPacket dp = new DatagramPacket(data,data.length);
   ```

3. 调用DatagramSocket对象的方法接收数据

   void receive(DatagramPacket p)

   ```java
   ds.receive(dp);
   ```

4. 解析数据包，并把数据在控制台显示

   byte[] getData()

   int getLength()

   ```java
   byte[] dpData = dp.getData();
   int len = dp.getLength();
   String s = new String(dpData,0,len);
   System.out.println(s);
   ```

5. 关闭接收端

   void close()

   ```java
   ds.close();
   ```

#### TCP发送数据

1. 创建客户端的Socket对象（Socket）

   Socket(String host,int port)

   ```
   Socket socket = new Socket("172.17.24.101",12222);
   ```

2. 获取输出流

   ```
   OutputStream outputStream = socket.getOutputStream();
   outputStream.write("hello,刘思梦,我来了".getBytes());
   ```

3. 释放资源

   ```
   socket.close();
   ```

#### TCP接收数据

1. 创建服务器端的Socket对象（ServerSocket）

   ```
   ServerSocket ss = new ServerSocket(12222);
   ```

2. 监听客户端连接，返回一个Socket对象

   ```
   Socket accept = ss.accept();
   ```

3. 获取输入流，读数据，并把数据显示在控制台中

   ```
   InputStream inputStream = accept.getInputStream();
   byte[] bys = new byte [1024];
   int len = inputStream.read(bys);
   String s = new String(bys,0,len);
   System.out.println("数据是："+s);
   ```

4. 释放资源

   ```
   accept.close();
   ss.close();
   ```

#### Lambda表达式

- 参数类型可以省略
- 但是有多个参数的情况下，要么全省略类型，要么都不省略
- 如果参数仅有一个，那么小括号可以省略
- 如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉

#### Lambda表达式注意事项

- 使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法
- 必须有上下文环境，才能推导出Lambda对应的接口
  - 根据局部变量的赋值得知Lambda对应的接口：Runnable r = () -> System.out.println(".....");
  - 根据调用方法的参数得知Lambda对应的接口：new Thread(() -> Systen.out.println(".....")).start();

#### 接口组成更新概述

- 常量
  - public static final
- 抽象方法
  - public abstract
- 默认方法（Java 8）
- 静态方法（Java 8）
- 私有方法（Java 9）

#### 接口中默认方法

接口中默认方法的定义格式：

- 格式：public **default** 返回值类型 方法名（参数列表）{   }
- 范例：public **default** void show(){    }

接口中默认方法的注意事项：

- 默认方法不是抽象方法，所以不强制被重写，但是可以重写，重写的时候要去掉default关键字
- public可以省略，default不能省略

#### 接口中静态方法

接口中静态方法的定义格式：

- 格式：public **static** 返回值类型  方法名（参数列表）{   }
- 范例：public **static** void show() {   }

接口中静态方法的注意事项：

- 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
- public 可以 省略，static不能省略

#### 接口中私有方法

接口中私有方法的定义格式：

- 格式1：private 返回值类型 方法名（参数列表）{   }
- 范例1：private void show(){   }
- 格式2：private static 返回值类型 方法名（参数列表）{   }
- 范例2：private static show() {    }

接口中私有方法的注意事项：

- 默认方法可以调用私有的静态方法或者非静态方法
- 静态方法只能调用私有的静态方法

#### 方法引用符

方法引用符

- ::该符号为引用运算符，而它所在的表达式被称为方法引用

#### 函数式接口

函数式接口：有且仅有一个抽象方法的接口

Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导

如何检测一个接口是不是函数式接口呢？

- @Functionallnterface
- 放在接口定义的上方：如果接口是函数式接口，编译通过，如果不是，编译失败

注意：

- 我们定义函数式接口的时候，@Functionallnterface是可选的，就算我不写注解，只要保证满足函数式接口定义的条件，也照样是函数式接口，但是，建议加上该注解。

------

#### 2019年11月1日

#### 1. 体验一下面试官对于消息队列的7个连环炮

#### 2. 如何进行消息队列的技术选型？

- 解耦：A系统发送个数据到BCD系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统还要时时刻刻考虑BCD系统如果挂了咋办？要不要重发？头都大了。。。。

  **不用MQ解耦的场景**

  ![不用mq解耦是的场景](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\01\图片.png)

  **使用MQ解耦的场景**

  ![使用MQ解耦的场景](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\02\04_使用MQ进行异步化之后的接口性能优化.png)

![](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\02\图片.png)

- **使用MQ的缺点**

  - 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了怎么办，整个系统都宕机了
  - 系统复杂性提高：硬生生加了MQ进来，怎么保证消息没有重复消费，怎么处理消息丢失，问题一大堆
  - 一致性问题：A系统处理完了直接返回成功了，都以为请求成功了，要是BCD系统中，BC成功了，D失败了，数据就不一致了。

- **kafka、rocketMq、rabbitMq、activeMq都有什么优缺点？**

  | 特性                    | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
  | ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 单机吞吐量              | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 10万级，RocketMQ也是可以支撑高吞吐的一种MQ                   | 10万级别，这是kafka最大的优点，就是吞吐量高。 一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
  | topic数量对吞吐量的影响 |                                                              |                                                              | topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降 这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic | topic从几十个到几百个的时候，吞吐量会大幅度下降 所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 |
  | 时效性                  | ms级                                                         | 微秒级，这是rabbitmq的一大特点，延迟是最低的                 | ms级                                                         | 延迟在ms级以内                                               |
  | 可用性                  | 高，基于主从架构实现高可用性                                 | 高，基于主从架构实现高可用性                                 | 非常高，分布式架构                                           | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
  | 消息可靠性              | 有较低的概率丢失数据                                         |                                                              | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置，消息可以做到0丢失                          |
  | 功能支持                | MQ领域的功能极其完备                                         | 基于erlang开发，所以并发能力很强，性能极其好，延时很低       | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
  | 优劣势总结              | 非常成熟，功能强大，在业内大量的公司以及项目中都有应用 偶尔会有较低概率丢失消息 而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本 而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 | erlang语言开发，性能极其好，延时很低； 吞吐量到万级，MQ功能比较完备 而且开源提供的管理界面非常棒，用起来很好用 社区相对比较活跃，几乎每个月都发布几个版本分 在国内一些互联网公司近几年用rabbitmq也比较多一些 但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。 而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。 而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。 | 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障 日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码 还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的 | kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量 而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略 这个特性天然适合大数据实时计算以及日志收集 |

  综上所述，各种对比之后，我个人倾向于是：

  一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；

  后来大家开始用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，对公司而言，几乎处于不可控的状态，但是确实人是开源的，比较稳定的支持，活跃度也高；

  不过现在确实越来越多的公司，会去用RocketMQ，确实很不错，但是我提醒一下自己想好社区万一突然黄掉的风险，对自己公司技术实力有绝对自信的，我推荐用RocketMQ，否则回去老老实实用RabbitMQ吧，人是活跃开源社区，绝对不会黄

  所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择

  如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范



 





