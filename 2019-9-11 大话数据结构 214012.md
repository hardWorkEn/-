# 大话数据结构

###### 1.数据元素

```
数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
```

###### 2.数据项

```
数据项：一个数据元素可以由若干个数据项组成。
数据项是数据不可分割的最小单位。
```

###### 3.数据对象

```
数据对象：是性质相同的数据元素的集合，是数据的子集。
```

###### 4.数据结构

```
数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
```



| 逻辑结构 |   物理结构   |
| :------: | :----------: |
| 集合结构 | 顺序存储结构 |
| 线性结构 | 链表存储结构 |
| 树形结构 |              |
| 图形结构 |              |

## 第二章：算法

> 算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

> 算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。

### 算法时间复杂度

> 定义：在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T（n）= O（f(n)）。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f（n）是问题规模n的某个函数。

### 推导大O阶方法

​	那么如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？我们给出了下面的推导方法：

```
推导大O阶：
1.用常数1取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。
```

> 常用的时间复杂度所耗费的时间从小到大依次是：

![1568116349114](C:\Users\RYQBDYQ\AppData\Local\Temp\1568116349114.png)

## 第三章：线性表

> 定义：零个或多个数据元素的有限序列。

**顺序存储结构插入算法思路：**

```
1.如果插入位置不合理，抛出异常。
2.如果线性表长度大于等于数组长度，则抛出异常。
3.从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一位。
4.将要插入元素填入位置i处。
5.表长+1。
```

**顺序存储结构删除算法思路：**

```
1.如果删除位置不合理，抛出异常。
2.取出删除元素。
3.从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置。
4.表长-1。
```

**线性表顺序存储结构的优缺点：**

```
优点：	
	1，无须为表示表中元素之间的逻辑关系而增加额外的存储空间。
	2，可以快速地存取表中任一位置的元素。
缺点：
	1，插入和删除操作需要移动大量元素。
	2，当线性表长度变化较大时，难以确定存储空间的容量。
	3，造成存储空间的"碎片"。
```

**线性表链式存储结构头指针和头结点的异同：**

```
头指针：
	1，头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。
	2，头指针具有标识作用，所以常用头指针冠以链表的名字。
	3，无论链表是否为空，头指针均不为空，头指针是链表的必要元素。
	
头结点：
	1，头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义
	2，有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了。
	3，头结点不一定是链表必须要素。
```

**获得链表第i个数据的算法思路：**

```
1，声明一个结点P指向链表第一个结点，初始化j从1开始。
2，当j<i时，就遍历链表，让P的指针向后移动，不断指向下一结点，j累加1。
3，若到链表末尾P为空，则说明第i个元素不存在。
4，否则查找成功，返回结点P的数据。
```

**单链表第i个数据插入结点的算法思路：**

```
1，声明一结点P指向链表第一个结点，初始化j从1开始。
2，当j<i时，就遍历链表，让P的指针向后移动，不断指向下一结点，j累加1。
3，若到链表末尾P为空，则说明第i个元素不存在。
4，否则查找成功，在系统中生成一个空结点S。
5，将数据e赋给s->data。
6，单链表的插入标准语句s->next=p->next;p->next=s。
7，返回成功。
```

**单链表第i个数据删除结点的算法思路：**

```
1，声明一结点P指向链表第一个结点，初始化j从1开始
2，当j<i时，就遍历链表，让P的指针向后移动，不断指向下一个结点，j累加1
3，若到链表末尾P为空，则说明第i个元素不存在
4，否则查找成功，将欲删除的结点p->next赋值给q
5，单链表的删除标准语句为p->next=q->next
6，将q结点中的数据赋值给e,作为返回
7，释放q结点
8，返回成功
```

