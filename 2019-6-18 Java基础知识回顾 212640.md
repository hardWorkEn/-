# Java基础知识回顾

## 1.面向对象和面向过程的区别

### 面向过程

**优点：**性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素时，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发 。

**缺点：**没有面向对象易维护，易复用，易扩展。

### 面向对象

**优点：**易维护，易复用，易扩展，由于面向对象有封装，继承，多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。

**缺点：**性能比面向过程低。

## 2.Java语言有哪些特点？

1. 简单易学
2. 面向对象
3. 平台无关性
4. 可靠性
5. 安全性
6. 支持多线程
7. 支持网络编程
8. 编译与解释并存

## 3.构造器Constructor是否可被override？

在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 

## 4.重载和重写的区别

**重载：**发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

**重写：**发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法访问修饰符为private则子类就不能重写该方法。

## 5.String、StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？

**可变性**

String类中使用final关键字修饰字符数组来保存数组，`private final char value[]`，所以String对象是不可变的。而StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串`char[]value`，但是没有用final关键字修饰，所以这两种对象都是可变的。

**线程安全性**

String中的对象时不可变的，也就可以理解为常量，线程安全，AbstractStringBuilder是StringBuilder与StringBuffer的公共父类。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以线程是安全的，StringBuilder并没有对方法加同步锁，所以是非线程安全的。

**性能**

每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%-15%左右的性能提升，但要冒着线程不安全的风险。

**对于三者的总结**

1. 操作少量的数据：适合用String
2. 单线程操作字符串缓冲区下操作大量数据：适合用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据：适合用StringBuffer

## 6.自动装箱与拆箱

**装箱：**将基本类型用对应的包装类型包装起来。

**拆箱：**将包装类型转换为基本类型。

## 7.在一个静态方法内调用一个非静态成员为什么是非法的？

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

## 8.接口和抽象类的区别？

1. 接口的方法默认是public，所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类则不一定。
3. 一个类 可以实现多个接口，但只能实现一个抽象类，接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以是public、protected和default这些（抽象方法就是为了被重写而不能使用private关键字修饰）。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 

**备注：**在JDK8中，接口也可以定义静态方法，可以直接用接口名调用，实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。 

## 9.成员变量与局部变量的区别有哪些？

1. 成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数，成员变量可以被public、private、static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰，但是成员变量和局部变量都能被final修饰。
2. 从变量在内存中的存储方式来看，如果成员变量时使用`static`修饰的，那么这个成员变量时属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的，而对象存在于堆内存，局部变量则存在于栈内存。
3. 从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋值则自动以类型的默认值而赋值（一种情况例外被final修饰的成员变量也必须显示地赋值），而局部变量则不会自动赋值。

## 10.静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以 使用`类名.方法名`的方式，也可以使用`对象名.方法名`的方式，而实例方法只有后面这种方式，也就是说，静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法，实例方法无此限制。

## 11.==与equals

**==：**它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）

**equals：**它的作用是判断两个对象是否相等，但它一般有两种情况使用：

+ 类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较两个对象。
+ 类覆盖了equals()方法，一般，我们都覆盖equals()方法来比较两个对象的内容是否相等，若它们的内容相等，就返回true。

**举个例子：**

```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```

**说明：**

+ String中的equals方法是被重写过的，因为Object中的equals方法是比较的对象的内存地址，而String的equals方法比较的是值。
+ 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用，如果没有就在常量池中创建一个String对象。

## 12.hashcode与equals

面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” 

#### **为什么要有hashcode**

我们先以“hashSet”如何检查重复为例子来说明为什么要有hashcode：当你把对象加入hashset时，HashSet会先计算对象的hashcode值来判断对象加入的位置。同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，hashset会假设没有对象重复出现。但是如果发现有相同的hashcode值的对象，这时就会调用`equals()`方法来检查hashcode相等对象是否真的相同。如果相同，HashSet就不会让其加入。

我们可以看出：`hashcode()`的作用就是获取**哈希码**，也称为散列码，他实际上是返回一个int整数，这个哈希码的作用就是确定该对象在哈希表中的索引位置。

#### hashcode()与equals()的相关规定

1. 如果两个对象相等，则hashcode一定也是相同的。
2. 两个对象相等，对两个对象分别调用equals方法都返回true
3. 两个对象有相同的hashcode值，它们也不一定是相等的
4. **因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

## 13.线程有哪些基本状态?

![Java线程状态变迁](https://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67) 

由上图看出：

线程创建之后它将处于**NEW（新建）**状态，调用`start`方法后开始运行，线程这时候处于**READY（可运行）**状态。可运行状态的线程获得了cpu时间片（timeslice）后就处于**RUNNING（运行）**状态。

> 操作系统隐藏 Java虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：[HowToDoInJava](https://howtodoinjava.com/)：[Java Thread Life Cycle and Thread States](https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/)），所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态 。 

![RUNNABLE-VS-RUNNING](https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67) 

当线程执行`wait()`方法之后，线程进入`WAITING（等待）`状态，进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而`TIME_WAITING（超时等待）`状态相当于在等待状态的基础上增加了超时限制，比如通知`sleep（long millis）`方法或`wait（long millis）`方法可以将Java线程置于TIMED WAITING状态。当超时时间到达后Java线程将会返回RUNNABLE状态，当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的`run()`方法之后将会进入到 **TERMINATED（终止）** 状态。 

## 14.关于final关键字的一些总结

final关键字主要用在三个地方：变量、方法、类。 

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦被初始化之后便不能更改，如果是引用数据类型的变量，则在对初始化之后便不能在让其指向另一个对象。
2. 在用final修饰一个类时，表明这个类不能被继承，final类中的所有成员方法都会被隐式地指定为final方法。
3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 

## 15.Java中的异常处理

![Java异常类层次结构图](https://camo.githubusercontent.com/27aa104d93ba0738be0f3d2e7d5b096c1619d12d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67) 

在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 **Throwable类**。Throwable： 有两个重要的子类：**Exception（异常）** 和 **Error（错误）** ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。

**Error（错误）:是程序无法处理的错误**，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时  JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM  不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。

这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual  MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之  外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在  Java中，错误通过Error的子类描述。

**Exception（异常）:是程序本身可以处理的异常**。Exception 类有一个重要的子类 **RuntimeException**。RuntimeException 异常由Java虚拟机抛出。**NullPointerException**（要访问的变量没有引用任何对象时，抛出该异常）、**ArithmeticException**（算术运算异常，一个整数除以0时，抛出该异常）和 **ArrayIndexOutOfBoundsException** （下标越界异常）。

**注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。**

### Throwable类常用方法

- **public string getMessage()**:返回异常发生时的详细信息
- **public string toString()**:返回异常发生时的简要描述
- **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
- **public void printStackTrace()**:在控制台上打印Throwable对象封装的异常信息

### 异常处理总结

- **try 块：**用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
- **catch 块：**用于处理try捕获到的异常。
- **finally 块：**无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

**在以下4种特殊情况下，finally块不会被执行：**

1. 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
2. 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
3. 程序所在的线程死亡。
4. 关闭CPU。

**关于返回值：**

如果try语句里有return，返回的是try语句块中变量值。 详细执行过程如下：

1. 如果有返回值，就把返回值保存到局部变量中；
2. 执行jsr指令跳到finally语句里执行；
3. 执行完finally语句后，返回之前保存在局部变量表里的值。
4. 如果try，finally语句里均有return，忽略try的return，而使用finally的return。

## 16.Java 中 IO 流分为几种?BIO,NIO,AIO 有什么区别?

### java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

按操作方式分类结构图： 

![按操作方式分类结构图：](https://camo.githubusercontent.com/50f105c85f6b42d643d46e1ac7bb0f855b92cd9d/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31362f313633363764346664316365316234363f773d37323026683d3130383026663d6a70656726733d3639353232)

按操作对象分类结构图 ：

![按操作对象分类结构图](https://camo.githubusercontent.com/8957efacdf1cd4eac15d844da8353a7f77a3c863/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f31362f313633363764363733623065323638643f773d37323026683d35333526663d6a70656726733d3436303831) 

### BIO,NIO,AIO 有什么区别?

- **BIO (Blocking I/O):**  同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的  I/O  并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的  BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
- **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型，在Java 1.4  中引入了NIO框架，对应 java.nio 包，提供了 Channel ,  Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。  NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel`   两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用  NIO 的非阻塞模式来开发
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了  NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO  是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO  是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在  IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO  的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。 





