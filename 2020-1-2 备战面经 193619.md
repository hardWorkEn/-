# 备战面经

## 设计模式

+ 单例模式

  ```
  特点：
  类构造器私有
  持有自己类型的属性
  对外提供获取实例的静态方法
  ```

  + 懒汉、恶汉、双重校验锁、静态内部类

  ```java
  懒汉：线程不安全，延迟初始化
  public class Singleton{
  	private static Singleton instance;
  	private Singleton(){}
      public static Singleton getInstance(){
     		if(instance == null){
     			instance = new SingleTon();
     		}
    		return instance; 		
      }
  }
  饿汉：线程安全，比较常用，容易产生垃圾，因为一开始就初始化
  public class Singleton{
  	private Singleton(){}
  	private static Singleton instance = new Singleton();
      public static Singleton getInstance(){
      	return instance;
      }
  }
  双重锁模式：线程安全，延迟加载，能在多线程情况下保持高性能
  public class Singleton{
  	private volatile static Singleton instance;
  	private Singleton(){}
      public static Singleton getInstance(){
      	if(instance == null){
          	synchronized(Singleton.class){
              	if(instance == null){
              		instance = new Singleton();
              	}	
         		}
      	}
          return instance;
      }
  }
  静态内部类
  public class Singleton{
  	private Singleton(){}
      public static Singleton getInstance(){
      	return Inner.instance;
      }
      private static class Inner{
      	private static final Singleton instance = new Singleton();
      }
  }
  ```

+ 工厂模式


## JAVA基础

+ 抽象类和接口区别

  ```
  1.接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
  2.接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
  3.一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
  4.接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。
  ```

+ 集合类的结构
  
+ Iterator、Collection（List、Set、Queue）、Map
  
+ ArrayList和LinketList的区别

  ```
  ArrayList 底层实现就是数组，且ArrayList实现了RandomAccess，表示它能快速随机访问存储的元素，通过下标 index 访问，只是我们需要用 get() 方法的形式， 数组支持随机访问， 查询速度快， 增删元素慢；
  LinkedList 底层实现是链表， LinkedList 没有实现 RandomAccess 接口，链表支持顺序访问， 查询速度慢，增删元素快
  两者都是线程不安全的
  ```

+ List和Set区别

  ```
  list可以允许重复的对象，set不允许重复对象
  list可以插入多个null对象，set只允许插入一个null元素
  list有序，保证了每个元素的插入顺序，set是无序的
  ```

+ 重写equal为什么要重写hashcode

  ```
  https://www.jianshu.com/p/75d9c2c3d0c1
  ```

+ GET和POST区别

  ```java
  1.GET在浏览器回退时是无害的，而POST会再次提交请求
  2.GET产生的URL地址可以被Bookmark,而POST不可以
  3.GET请求会被浏览器主动cache，而POST不会
  4.GET请求只能进行url编码，而POST可以支持多种编码方式
  5.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
  6.GET请求在URL中有长度限制，而POST没有
  7.GET只接受ASCII字符，而POST没有限制
  8.GET比POST更不安全，参数直接暴露在URL中，不能传递敏感信息
  9.GET参数通过URL传递，POST放在request body中
  ```

+ String的底层原理

  ```
  底层是一个不可变字符串，是一个char类型的数组，使用连接符的时候，实际上是经过了StringBuilder的优化处理的，并不是在原来的String对象中做追加。
  ```

##  HashMap

+ 底层结构
  + 数组+链表
+ Put的过程
+ 为什么长度是2的倍数
  + 找索引时key的hash值与数组的长度值减1进行运算，长度为2的倍数时能减少碰撞
+ JDK1.7和1.8中HashMap的区别
  + 1.8增加红黑树、头插变为尾插、扩容后元素位置要么在原位置，要么在原位置+扩容前旧容量
+ 为什么线程不安全
  + 扩容时链表可能形成闭环
+ ConcurrentHashMap怎么保证线程安全
+ ConcurrentHashMap和HashMap的区别
+ HashMap的原理，用红黑树解决了什么问题
+ hash冲撞怎么办？如何rehash
+ HashMap的遍历方式
+ volatile和synchronized的区别
+ Synchronized和Lock的区别
+ Lock底层实现
+ volatile怎么保证可见性
+ synchronized的原理
+ 自旋锁的好处
+ HashMap如何扩容，为什么长度是2的幂次

```
为了能让HashMap减少碰撞，分配均匀，
```

+ HashMap初始化默认长度，初始化长度为7会怎么样

+ HashMap在1.8有什么改进

+ HashMap什么时候转红黑树

+ 为什么8转红黑树，6退化为链表

+ HashMap为什么线程不安全

+ ConcurrentHashMap为什么线程安全

+ ConcurrentHashMap锁分段在1.8怎么实现

+ ThreadLocal的作用

+ HashMap和HashSet的区别

  + 如果你看过 `HashSet` 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 `clone() `、`writeObject()`、`readObject()`是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。

  |         HashMap          |                        HashSet                         |
  | :----------------------: | :----------------------------------------------------: |
  |      实现了Map接口       |                     实现了Set接口                      |
  |        存储键值对        |                        存储对象                        |
  | 调用put()向map中添加元素 |                调用add()想Set中添加元素                |
  |   使用键来计算HashCode   | 使用对象来计算HashCode值，使用equals()判断对象的相等性 |

+ HashMap和HashTable的区别

```
1.线程是否安全：HashMap是非线程安全的，HashTable是线程安全的，内部的方法都经过synchronized修饰
2.效率：因为线程安全的问题，HashMap比HashTable效率高一点
3.对Null Key和Null Value的支持：HashMap中null可以作为键和值，只能有一个键，HashTable中只要put进一个null键，直接抛出NullPointerException
4.初始容量和扩容容量的大小：创建时不指定容量初始值，HashMap默认的初始大小为11，之后每次扩容，容量变为原来的2n+1。HashMap默认的初始化大小为16，每次扩容为之前的2倍。创建时给定初始值，HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。
5.底层数据结构：JDK1.8之后HashMap当链表长度大于等于8时，将链表转化为红黑树。
```

+ ArrayList扩容机制

```

```

+ ArrayList与LinkedList区别

```java
1.是否线程安全：两者都是线程不安全的
2.底层数据结构：ArrayList底层使用的是object数组，LinkedList底层使用的双向链表数据结构
3.插入和删除是否受元素位置影响：①ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响，②LinkedList采用链表存储，所以不受元素位置的影响。
4.是否支持随机快速访问：LinkedList不支持高效的随机元素访问，ArrayList支持。
5.内存空间占用：ArrayList的空间浪费主要是体现在List的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在他的每一个元素都需要消耗比ArrayList更多的空间（要存放直接后继和直接前驱以及数据）
```

## 线程池

+ 线程池常用参数
  + 核心线程数，最大线程数，阻塞队列，线程最大存活时间

```
corePoolSize:核心线程数，当有任务进来的时候，如果当前线程还未达到corePoolSize个数，则创建核心线程，核心线程有几个特点：
一：当线程数未达到核心线程最大值的时候，新任务进来，即使有空闲线程，也不会复用，仍然新建核心线程。
二：核心线程一般不会被销毁，即使是空闲的状态，如果通过方法allowCoreThreadTimeOut(boolean value)设置为true时，超时也同样会被销毁。
三：生产环境首次初始化的时候，可以调用prestartCoreThread()方法来预先创建所有核心线程，避免第一次调用缓慢。
maximumPoolSize:除了有核心线程外，有些策略是当核心线程完全无空闲的时候，还会创建一些临时的线程来处理任务，maximumPoolSize 就是核心线程 + 临时线程的最大上限。临时线程有一个超时机制，超过了设置的空闲时间没有事儿干，就会被销毁
keepAliveTime:超时时间，也就是最大空闲时间，默认用于非核心线程。
unit:超时的时间单位
workQueue:等待执行的任务队列，如果核心线程没有空闲的了，新来的任务就会被放到这个等待队列。
ThreadFactory:是一个接口，用于实现生成线程的方式，可以用Executors.defaultThreadFactory()默认的实现
handle:当没有空闲的线程处理任务，并且等待队列已满（对有界队列有效），再有新任务进来的话，就要做一些取舍了。
一：ThreadPoolExecutor.AbortPolicy:直接抛出异常，这是默认策略。
二：ThreadPoolExecutor.DiscardPolicy:直接丢弃任务，不抛出异常。
三：ThreadPoolExecutor.DiscardOldPolicy:直接丢弃等待时间最久的任务，然后将新任务加入队列
四：ThreadPoolExecutor.CallerRunsPolicy:由线程池所在的线程处理该任务。
```

+ 线程池工作流程

```
1.如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务
2.如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
3.如果队列满了，而且正在运行的线程数量小于maximumPoolSize，那么创建非核心线程运行这个任务
4.如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么执行拒绝策略
当一个线程完成任务时，会从队列中取下一个任务来执行。
当一个线程无事可做，超过一定时间（KeepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么非核心线程会被回收，当所有任务完成后，线程池会收缩到corePoolSize的大小。
```

+ 线程池的类别和区别

  ```
  newCachedThreadPool:
      一：重用之前的线程
      二：适合执行许多短期异步任务的程序
      三：调用execute()将重用以前构造的线程
      四：如果没有可用的线程，则创建一个新线程并添加到池中
      五：默认为60s未使用就被终止和移除
      六：长期闲置的池将不会消耗资源
  newWorkStealingPool:
  	一：获取当前可用的线程数量进行创建作为并行级别
  	二：使用ForkJoinPool
  newSingleThreadPool:
  	一：任何情况下都不会有超过一个任务处于活动状态
  	二：能保证执行顺序，先提交的先执行
  	三：当线程执行中出现异常，创建一个新的线程替换之
  newFixedThreadPool:
  	一：创建固定数量的线程池
  	二：当所有线程都处于活动状态时，如果提交了其他任务，将会在队列中等待一个线程可用
  	三：线程会一直存在，直到调用shutdown
  newScheduledThreadPool:
  	一：设定延迟时间，定期执行
  	二：空闲线程会进行保留
  	
  submit()：提交一个线程任务，可以接受回调函数的返回值
  execute():执行一个任务，没有返回值
  shutdown():表示不再接受新任务，但不会强行终止已经提交或者正在执行中的任务
  shutdownNow():对于尚未执行的任务全部取消，正在执行的任务全部发出interrupt()，停止执行。
  ```

+ 阻塞队列的类别和区别

```
https://www.jianshu.com/p/9e4eca73553c
```

## JVM

+ 内存结构和各自存放的内容
  + 方法区、堆、虚拟机栈、本地方法栈、程序计数器

```

```

+ 新生代和老年代的垃圾回收算法
  + 新生代->复制、老年代->标记-整理（CMS用的标记-清除）
+ CMS/G1的流程
  + 初始标记->并发标记->重新标记->并发清除
+ CMS/G1的特点和区别
  + CMS：尽可能的减少停顿时间，采用标记-清除，会造成内存碎片化
  + G1：可以预测停顿时间，采用标记-整理，减少内存碎片化，将内存划分为region粒度
+ 判断垃圾是否可以回收的方法
  + 引用计数法、可达性分析算法
+ 哪些对象可以作为GCRoots
+ OOM可能是什么原因导致的
+ 并发控制可以用哪些方式实现
+ 线程池的大小该如何设置
+ 堆和栈的区别
+ 递归调用是在堆上还是栈上

## Spring

+ IOC和AOP的含义和原理
+ Spring、Springboot、Springmvc的区别
+ Springboot的启动流程
+ Bean的生命周期
+ Springmvc的流程
+ Springboot的优势

## MySQL

### 事务

+ 什么是事务

```
事务就是一组独立不可分割的工作单元，事务的操作要么全部执行，要么都不执行。
```

+ 事务的特性（ACID），详细说明各个特性的含义
  + 原子性、一致性、隔离性、持久性

```
原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么全部不执行。
一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。
隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
持久性：一个事务被提交之后，他对数据库数据的改变是持久的，即便数据库发生故障也不应该对其有任何影响。
```

+ 事务隔离级别
  + 未提交读、已提交读、可重复读、串行化

```
READ-UNCOMMITTED(未提交读)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读。
READ-COMMITTED(已提交读)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读和不可重复读仍有可能发生。
REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是相同的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读，不可重复读以及幻读。
```

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| READ-UNCOMMITTED |  √   |     √      |  √   |
|  READ-COMMITTED  |  ×   |     √      |  √   |
| REPEATABLE-READ  |  ×   |     ×      |  √   |
|   SERIALIZABLE   |  ×   |     ×      |  ×   |

+ 脏读、不可重复读、幻读的区别

```
脏读(Dirty read)：当一个事务正在访问数据并对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。
丢失修改(Lost to modify)：指在一个事务读取一个数据时，另外一个事务也访问了这个数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务的修改结果就会丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取到A=20，事务1修改A=19，事务2也修改A=18，最终结果A=18，事务1的修改被丢失。
不可重复读(Unrepeatableread)：指在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也访问了该数据，那么在第一次事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
幻读(Phantom read)：幻读和不可重复读类似，他发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据，在随后的查询中，第一个事务就会发现一些原本不存在的记录。
```

> 不可重复读和幻读区别：不可重复读的重点是修改，比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除，比如多次读取一条记录发现记录增多或减少了。

+ Innodb和Mysiam索引区别

```
一、InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的。
InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。
InnoDB是聚簇索引，数据在索引之下。
二、MyISAM使用的是表锁，InnoDB使用行锁
三、MyISAM不支持事务和MVCC，InnoDB支持事务和MVCC
四、MyISAM支持FULLTEXT类型的全文索引，InnoDB不支持FULLTEXT类型的全文索引
五、MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址，InnoDB如果没有设定主键或非空唯一索引，就会生成一个6字节的主键，数据是主索引的一部分，辅助索引保存的是主索引的值。
六、MyISAM不支持外键，InnoDB支持外键。
```

+ left join,right join区别

```
left join在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录
right join在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录
```

+ 了解SQL注入吗
+ 从服务端如何防止SQL注入

```

```



+ 数据库如何加行级锁
+ 慢查询SQL怎么排查

### 索引

+ 常用索引（B树、Hash）
+ 聚簇索引和非聚簇索引的区别

```

```



+ 联合索引和单个索引的区别，联合索引的最左匹配原则
+ B树和B+树的区别
  + B+树的非叶子节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”
  + B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，因此B+树查找更稳定
  + 对于范围查找来说，B+树只要遍历叶子节点链表即可，B树却要重复地中序遍历
+ B+数的原理和优势
+  数据库索引的原理
+ mysql的回表
+ mysql优化
+ 线程池原理
+ 线程池参数怎么配置

## Redis

+ Redis的五种数据结构
  + String、Hash、List、Set、Zset
+ Redis为什么快
  + 内存，单线程，IO多路复用
+ Redis持久化
  + RDB、AOF
+ Redis高可用
  + 哨兵机制、Redis Cluster、持久化
+ zset的底层原理

## 计算机网络

+ 点击一个URL到页面返回，发生了什么
  + 客户端传给服务端时经过TCP/IP四层模型，中途依次加入HTTP报文、TCP报文、IP报文、MAC报文，然后逆序依次拆包
+ OSI七层模型&TCP/IP四层模型
+ cookie和session的区别
+ HTTP如何保持长连接

### TCP & UDP

+ TCP三次握手，四次挥手的流程（最好能画图，说明各阶段状态）

```

```

+ 为什么需要三次握手
  + 防止已过期的链接再次传到被连接的主机
+ 为什么需要四次挥手，断开连接时为什么比建立连接多一次
  + 服务端的ACK和FIN一般都会分开发送，ACK表示自己收到了客户端的断开请求（但还有数据没传输完），FIN表示自己传输完了数据
+ TCP 和UDP的区别

```
UDP在传送数据之前不需要先建立连接，远程主机在收到UDP报文后，不需要给出任何确认。

```

|      |              |            |            |          |          |                  |          |
| :--: | :----------: | :--------: | :--------: | :------: | :------: | :--------------: | -------- |
|      | 是否面向连接 | 传输可靠性 |  传输形式  | 传输效率 | 所需资源 |     应用场景     | 首部字节 |
| TCP  |   面向连接   |    可靠    |   字节流   |    慢    |    多    | 要求通信数据可靠 | 20-60    |
| UDP  |    无连接    |   不可靠   | 数据报文段 |    快    |    少    |  要求通信速度高  | 8个字节  |



+ TIME_WAIT的作用
  + 保证客户端发送的最后一个ACK报文能够到达服务器
  + 防止类似与三次握手中提到了的已经失效的连接请求报文段出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。

### HTTPS

+ HTTPS的优势
  + CA证书认证、加密传输
+ HTTPS建立数据流程
+ 为什么传输过程中采用对称加密，协商时采用非对称加密
  + 对称加密快

## 操作系统

### 进程 & 线程

+ 进程和线程的区别
+ 进程间通信方式
  + 管道、消息队列、信号量、共享内存
+ 线程间通信方式
  + 消息队列、全局变量

## Linux

+ 查找某个进程（ps aux |grep threadId）
+ 杀掉某个进程（kill,参数添加-9表示强制执行）
+ 查看某个端口是否被占用（netstat -anp|grep threadId）
+ 实时查看进程状态（top）

## 算法

+ 最大子序列
+ 反转链表
+ 数组中查找两数之和为k的序列对
+ 二分查找
+ 求二叉树中左叶子节点的总和
+ 从1亿个数找出前10
+ 

## 消息队列

+ rabbitmq和kafka的区别
+ rabbitmq如何保证事务
+ 消息队列的优势

## 分布式

+ 分布式缓存redis原理，zookeeper锁是如何实现的
+ 分布式缓存读写不一致的问题
+ 数据库调优
+ dubbo原理
+ 分布式缓存锁的实现
+ mysql分库分表原则





# 总结

+ 分布式必须了解，redis,dubbo,kafka
+ 数据库调优，组合索引和原理，事务
+ 并发，容器
+ spring aop ioc，mybatis
+ 算法
+ redis
+ 计算机网络
+ 项目

------

## 腾讯-医疗

### 一面

#### MySQL

+ 事务的特性
+ 如何删除表中的所有数据，delete和truncate的区别
+ char,varchar,text的区别
+ 一张表里数据量大，慢查询怎么办

#### Redis

+ redis的数据结构
+ zset的底层结构
+ redis的常用命令

#### 计算机网络

+ UDP如何重组数据
+ 应用层和网络层的作用
+ ARP是网络层的吗
+ TCP和UDP的报文头内容
+ HTTP
  + HTTP属于TCP还是UDP
  + HTTP1.1比1.0多了什么
  + HTTP Request Header中有哪些 内容
  + 如何判断是否是长连接
+ DNS属于TCP还是UDP，原理
+ Ping使用的什么协议，原理



------

------

#### 2019年10月30日		

#### 继承中变量的访问特点

在子类方法中访问一个变量

- 子类局部范围找
- 子类成员范围找
- 父类成员范围找
- 如果都没有就报错（不考虑父亲的父亲）

#### 继承中构造方法的访问特点

子类中所有的构造方法默认都会访问父类中无参的构造方法

- 因为子类会继承父类中的数据，可能还会使用父类中的数据。所以，子类初始化之前，一定要先完成父类数据的初始化
- 每一个子类构造方法的第一条语句默认都是：super()

如果父类中没有无参构造方法，只有带参构造方法，该怎么办？

- 通过使用super关键字去显示地调用父类中的带参构造方法
- 在父类中自己提供一个无参构造方法。

#### 继承中成员方法的访问特点

通过子类对象访问一个方法

- 子类成员范围找
- 父类成员范围找
- 如果都没有就报错（不考虑父亲的父亲）

#### 方法重写注意事项

- 私有方法不能被重写（父类私有成员子类是不能被继承的）
- 子类访问权限不能低于父类（public>默认>私有）

#### 自动建包

编译：**javac -d . HelloWorld.java**

运行：**java com.itheima.HelloWorld**

#### 权限修饰符

|  修饰符   | 同一个类中 | 同一个包中 | 不同包的子类 | 不同包的无关类 |
| :-------: | :--------: | :--------: | :----------: | :------------: |
|  private  |     √      |            |              |                |
|   默认    |     √      |     √      |              |                |
| protected |     √      |     √      |      √       |                |
|  public   |     √      |     √      |      √       |       √        |

#### final关键字

- 修饰方法：表明该方法是最终方法，不能被重写
- 修饰变量：表明该变量是常量，不能再次被赋值
- 修饰类：表明该类时最终类，不能被继承

#### final修饰局部变量

- 变量是基本类型：final修饰指的是基本类型的数据值不能改变
- 变量是引用类型：final修饰指的是引用类型的地址值不能改变，但是地址里面的内容是可以发生改变的。

#### static关键字

- 被类的所有对象共享
- 可以被类名调用

#### static访问特点

非静态的成员方法

- 能访问静态的成员变量
- 能访问非静态的成员变量
- 能访问静态的成员方法
- 能访问非静态的成员方法

静态的成员方法

- 能访问静态的成员变量
- 能访问静态的成员方法

**总结：静态成员方法只能访问静态成员。**

#### 多态中成员访问特点

- 成员变量：编译看左边，执行看左边
- 成员方法：编译看左边，执行看右边

为什么成员变量和成员方法的访问不一样呢？

- 因为成员方法有重写，而成员变量没有

#### 抽象类的成员特点

- 成员变量

  可以是变量也可以是常量

- 构造方法

  有构造方法，但是不能实例化

- 成员方法

  可以有抽象方法，限定子类必须完成某些动作

  也可以有非抽象方法，提高代码复用性

#### 接口的成员特点

- 成员变量：只能是常量，默认修饰符：public static final
- 构造方法：接口中没有构造方法
- 成员方法：只能是抽象方法，默认修饰符：public abstract

#### 抽象类与接口的区别

- 成员区别：
  - 抽象类：变量，常量，构造方法，抽象方法，非抽象方法
  - 接口：常量，抽象方法
- 关系区别：
  - 类与类：继承，单继承
  - 类与接口：实现，可以单实现，可以多实现
  - 接口与接口：继承，单继承，多继承

#### 内部类的访问特点

- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须创建对象

#### 成员内部类

- 在类的成员位置：成员内部类
- 在类的局部位置，局部内部类

成员内部类，外界如何创建对象使用呢？

- 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象
- 范例：Outer.Inner oi = new Outer().new Inner();

#### 局部内部类

```
局部内部类是在方法中定义的类，所以外界是无法直接使用的，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量。
```

#### int与String相互转换

- **int转换为String**
  - public static String valueOf(int i)：返回int参数的字符串形式。该方法是String类中的方法
- **String转换为int**
  - public static int parseInt(String s)：将字符串解析为int类型，该方法是Integer类中的方法

#### 异常体系

![1572435414874](C:\Users\RYQBDYQ\AppData\Local\Temp\1572435414874.png)

#### throws和throw区别

**throws**

- 用在方法后面，跟的是异常类名
- 表示抛出异常，由方法的调用者处理
- 表示出现异常的一种可能性，并不一定会发生异常

**throw**

- 用在方法体内，跟的是异常对象名
- 表示抛出异常，由方法体内的语句处理
- 执行throw一定抛出了某种异常

------

#### 2019年10月31号

#### 进程

- 进程是正在运行的程序，是系统进行资源分配和调用的独立单位。
- 每一个进程都有它自己的内存空间和系统资源。

#### 线程

- 是进程中的单个顺序控制流，是一条执行路径
- 单线程：一个进程如果只有一条执行路径，称为单线程程序
- 多线程：一个进程如果有多条执行路径，称为多线程程序

#### 多线程的实现方式

方式1：继承Thread类

- 定义一个类MyThread继承Thread类

- 在MyThread类中重写run()方法

- 创建MyThread类中的对象

- 启动线程

  - 两个小问题：

    - 为什么要重写run()方法？

      因为run()是用来封装被线程执行的代码

    - run()方法和start()方法的区别？

      run()：封装线程执行的代码，直接调用，相当于普通方法的调用

      start()：启动线程，然后由JVM调用此线程的run()方法

#### 网络编程三要素

**IP地址**

- 要想让网络中的计算机能够相互通信，必须为每一台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识

**端口**

- 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了，也就是应用程序的标识。

**协议**

- 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样，在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式，传输速率，传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换，常见的协议有UDP和TCP协议。

常用命令：

- ipconfig：查看本机IP地址
- ping IP地址：检查网络是否连通

特殊IP地址：

- 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用

#### InetAddress的使用

InetAddress：此类表示Internet协议地址

|                  方法名                   |                             说明                             |
| :---------------------------------------: | :----------------------------------------------------------: |
| static InetAddress getByName(String host) | 确定主机名称的IP地址，主机名称可以是机器名称，也可以是IP地址 |
|           String getHostName()            |                     获取此IP地址的主机名                     |
|          String getHostAddress()          |                 返回文本显示中的IP地址字符串                 |

协议：计算机网络中，连接和通信的规则被称为网络通信协议。

**UDP协议**

- 用户数据报协议（User Datagram Protocol）
- UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接，简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源较小，通信效率高，所以通常都会用于音频、视频和普通数据的传输，**在传输重要数据时不建议使用UDP协议**。

**TCP协议**

- 传输控制协议（Transmission Control Protocol）
- TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后在传输数据，它提供了两台计算机之间可靠无差错的数据传输，在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”
- 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠
  - 第一次握手，客户端向服务器端发出连接请求，等待服务器确认
  - 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求
  - 第三次握手，客户端再次向服务器端发送确认信息，确认连接
- 完成三次握手，连接建立后，客户端与服务器就可以开始进行数据传输了，由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛

#### UDP发送数据

1. 创建发送端的Socket对象（DatagramSocket）DatagramSocket()

   ```
   DatagramSocket ds = new DatagramSocket();
   ```

2. 创建数据，并把数据打包 DatagramPacket(byte[] bys,int length,InetAddress address,int port)

   ```
   byte[] bys = "hello,world".getBytes();
   int length = bys.length;
   InetAddress addr = InetAddress.getByName("172.17.24.101");
   int port = 10000;
   DatagramPacket dp = new DatagramPacket(bys,length, addr, port);
   ```

3. 调用DatagramSocket对象的方法发送数据 void send(DatagramPacket p)

   ```
   ds.send(dp);
   ```

4. 关闭发送端 void close()

   ```
   ds.close();
   ```

#### UDP接收数据

1. 创建接收端的Socket对象（DatagramSocket）

   DatagramSocket(int port)

   ```java
   DatagramSocket ds = new DatagramSocket(10000);
   ```

2. 创建一个数据包，用于接收数据

   DatagramPacket(byte[] buf,int length)

   ```java
   byte [] data = new byte[1024];
   DatagramPacket dp = new DatagramPacket(data,data.length);
   ```

3. 调用DatagramSocket对象的方法接收数据

   void receive(DatagramPacket p)

   ```java
   ds.receive(dp);
   ```

4. 解析数据包，并把数据在控制台显示

   byte[] getData()

   int getLength()

   ```java
   byte[] dpData = dp.getData();
   int len = dp.getLength();
   String s = new String(dpData,0,len);
   System.out.println(s);
   ```

5. 关闭接收端

   void close()

   ```java
   ds.close();
   ```

#### TCP发送数据

1. 创建客户端的Socket对象（Socket）

   Socket(String host,int port)

   ```
   Socket socket = new Socket("172.17.24.101",12222);
   ```

2. 获取输出流

   ```
   OutputStream outputStream = socket.getOutputStream();
   outputStream.write("hello,刘思梦,我来了".getBytes());
   ```

3. 释放资源

   ```
   socket.close();
   ```

#### TCP接收数据

1. 创建服务器端的Socket对象（ServerSocket）

   ```
   ServerSocket ss = new ServerSocket(12222);
   ```

2. 监听客户端连接，返回一个Socket对象

   ```
   Socket accept = ss.accept();
   ```

3. 获取输入流，读数据，并把数据显示在控制台中

   ```
   InputStream inputStream = accept.getInputStream();
   byte[] bys = new byte [1024];
   int len = inputStream.read(bys);
   String s = new String(bys,0,len);
   System.out.println("数据是："+s);
   ```

4. 释放资源

   ```
   accept.close();
   ss.close();
   ```

#### Lambda表达式

- 参数类型可以省略
- 但是有多个参数的情况下，要么全省略类型，要么都不省略
- 如果参数仅有一个，那么小括号可以省略
- 如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉

#### Lambda表达式注意事项

- 使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法
- 必须有上下文环境，才能推导出Lambda对应的接口
  - 根据局部变量的赋值得知Lambda对应的接口：Runnable r = () -> System.out.println(".....");
  - 根据调用方法的参数得知Lambda对应的接口：new Thread(() -> Systen.out.println(".....")).start();

#### 接口组成更新概述

- 常量
  - public static final
- 抽象方法
  - public abstract
- 默认方法（Java 8）
- 静态方法（Java 8）
- 私有方法（Java 9）

#### 接口中默认方法

接口中默认方法的定义格式：

- 格式：public **default** 返回值类型 方法名（参数列表）{   }
- 范例：public **default** void show(){    }

接口中默认方法的注意事项：

- 默认方法不是抽象方法，所以不强制被重写，但是可以重写，重写的时候要去掉default关键字
- public可以省略，default不能省略

#### 接口中静态方法

接口中静态方法的定义格式：

- 格式：public **static** 返回值类型  方法名（参数列表）{   }
- 范例：public **static** void show() {   }

接口中静态方法的注意事项：

- 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
- public 可以 省略，static不能省略

#### 接口中私有方法

接口中私有方法的定义格式：

- 格式1：private 返回值类型 方法名（参数列表）{   }
- 范例1：private void show(){   }
- 格式2：private static 返回值类型 方法名（参数列表）{   }
- 范例2：private static show() {    }

接口中私有方法的注意事项：

- 默认方法可以调用私有的静态方法或者非静态方法
- 静态方法只能调用私有的静态方法

#### 方法引用符

方法引用符

- ::该符号为引用运算符，而它所在的表达式被称为方法引用

#### 函数式接口

函数式接口：有且仅有一个抽象方法的接口

Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导

如何检测一个接口是不是函数式接口呢？

- @Functionallnterface
- 放在接口定义的上方：如果接口是函数式接口，编译通过，如果不是，编译失败

注意：

- 我们定义函数式接口的时候，@Functionallnterface是可选的，就算我不写注解，只要保证满足函数式接口定义的条件，也照样是函数式接口，但是，建议加上该注解。

------

#### 2019年11月1日

#### 1. 体验一下面试官对于消息队列的7个连环炮

#### 2. 如何进行消息队列的技术选型？

- 解耦：A系统发送个数据到BCD系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统还要时时刻刻考虑BCD系统如果挂了咋办？要不要重发？头都大了。。。。

  **不用MQ解耦的场景**

  ![不用mq解耦是的场景](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\01\图片.png)

  **使用MQ解耦的场景**

  ![使用MQ解耦的场景](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\02\04_使用MQ进行异步化之后的接口性能优化.png)

![](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\02\图片.png)

- **使用MQ的缺点**

  - 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了怎么办，整个系统都宕机了
  - 系统复杂性提高：硬生生加了MQ进来，怎么保证消息没有重复消费，怎么处理消息丢失，问题一大堆
  - 一致性问题：A系统处理完了直接返回成功了，都以为请求成功了，要是BCD系统中，BC成功了，D失败了，数据就不一致了。

- **kafka、rocketMq、rabbitMq、activeMq都有什么优缺点？**

  | 特性                    | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
  | ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 单机吞吐量              | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 10万级，RocketMQ也是可以支撑高吞吐的一种MQ                   | 10万级别，这是kafka最大的优点，就是吞吐量高。 一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
  | topic数量对吞吐量的影响 |                                                              |                                                              | topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降 这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic | topic从几十个到几百个的时候，吞吐量会大幅度下降 所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 |
  | 时效性                  | ms级                                                         | 微秒级，这是rabbitmq的一大特点，延迟是最低的                 | ms级                                                         | 延迟在ms级以内                                               |
  | 可用性                  | 高，基于主从架构实现高可用性                                 | 高，基于主从架构实现高可用性                                 | 非常高，分布式架构                                           | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
  | 消息可靠性              | 有较低的概率丢失数据                                         |                                                              | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置，消息可以做到0丢失                          |
  | 功能支持                | MQ领域的功能极其完备                                         | 基于erlang开发，所以并发能力很强，性能极其好，延时很低       | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
  | 优劣势总结              | 非常成熟，功能强大，在业内大量的公司以及项目中都有应用 偶尔会有较低概率丢失消息 而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本 而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 | erlang语言开发，性能极其好，延时很低； 吞吐量到万级，MQ功能比较完备 而且开源提供的管理界面非常棒，用起来很好用 社区相对比较活跃，几乎每个月都发布几个版本分 在国内一些互联网公司近几年用rabbitmq也比较多一些 但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。 而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。 而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。 | 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障 日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码 还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的 | kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量 而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略 这个特性天然适合大数据实时计算以及日志收集 |

  综上所述，各种对比之后，我个人倾向于是：

  一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；

  后来大家开始用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，对公司而言，几乎处于不可控的状态，但是确实人是开源的，比较稳定的支持，活跃度也高；

  不过现在确实越来越多的公司，会去用RocketMQ，确实很不错，但是我提醒一下自己想好社区万一突然黄掉的风险，对自己公司技术实力有绝对自信的，我推荐用RocketMQ，否则回去老老实实用RabbitMQ吧，人是活跃开源社区，绝对不会黄

  所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择

  如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范



 





