#### 2019年10月30日		

#### 继承中变量的访问特点

在子类方法中访问一个变量

* 子类局部范围找
* 子类成员范围找
* 父类成员范围找
* 如果都没有就报错（不考虑父亲的父亲）

#### 继承中构造方法的访问特点

子类中所有的构造方法默认都会访问父类中无参的构造方法

* 因为子类会继承父类中的数据，可能还会使用父类中的数据。所以，子类初始化之前，一定要先完成父类数据的初始化
* 每一个子类构造方法的第一条语句默认都是：super()

如果父类中没有无参构造方法，只有带参构造方法，该怎么办？

* 通过使用super关键字去显示地调用父类中的带参构造方法
* 在父类中自己提供一个无参构造方法。

#### 继承中成员方法的访问特点

通过子类对象访问一个方法

* 子类成员范围找
* 父类成员范围找
* 如果都没有就报错（不考虑父亲的父亲）

#### 方法重写注意事项

* 私有方法不能被重写（父类私有成员子类是不能被继承的）
* 子类访问权限不能低于父类（public>默认>私有）

#### 自动建包

编译：**javac -d . HelloWorld.java**

运行：**java com.itheima.HelloWorld**

#### 权限修饰符

|  修饰符   | 同一个类中 | 同一个包中 | 不同包的子类 | 不同包的无关类 |
| :-------: | :--------: | :--------: | :----------: | :------------: |
|  private  |     √      |            |              |                |
|   默认    |     √      |     √      |              |                |
| protected |     √      |     √      |      √       |                |
|  public   |     √      |     √      |      √       |       √        |

#### final关键字

* 修饰方法：表明该方法是最终方法，不能被重写
* 修饰变量：表明该变量是常量，不能再次被赋值
* 修饰类：表明该类时最终类，不能被继承

#### final修饰局部变量

* 变量是基本类型：final修饰指的是基本类型的数据值不能改变
* 变量是引用类型：final修饰指的是引用类型的地址值不能改变，但是地址里面的内容是可以发生改变的。

#### static关键字

* 被类的所有对象共享
* 可以被类名调用

#### static访问特点

非静态的成员方法

* 能访问静态的成员变量
* 能访问非静态的成员变量
* 能访问静态的成员方法
* 能访问非静态的成员方法

静态的成员方法

* 能访问静态的成员变量
* 能访问静态的成员方法

**总结：静态成员方法只能访问静态成员。**

#### 多态中成员访问特点

* 成员变量：编译看左边，执行看左边
* 成员方法：编译看左边，执行看右边

为什么成员变量和成员方法的访问不一样呢？

* 因为成员方法有重写，而成员变量没有

#### 抽象类的成员特点

* 成员变量

  可以是变量也可以是常量

* 构造方法

  有构造方法，但是不能实例化

* 成员方法

  可以有抽象方法，限定子类必须完成某些动作

  也可以有非抽象方法，提高代码复用性

#### 接口的成员特点

* 成员变量：只能是常量，默认修饰符：public static final
* 构造方法：接口中没有构造方法
* 成员方法：只能是抽象方法，默认修饰符：public abstract

#### 抽象类与接口的区别

* 成员区别：
  * 抽象类：变量，常量，构造方法，抽象方法，非抽象方法
  * 接口：常量，抽象方法
* 关系区别：
  * 类与类：继承，单继承
  * 类与接口：实现，可以单实现，可以多实现
  * 接口与接口：继承，单继承，多继承

#### 内部类的访问特点

* 内部类可以直接访问外部类的成员，包括私有
* 外部类要访问内部类的成员，必须创建对象

#### 成员内部类

* 在类的成员位置：成员内部类
* 在类的局部位置，局部内部类

成员内部类，外界如何创建对象使用呢？

* 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象
* 范例：Outer.Inner oi = new Outer().new Inner();

#### 局部内部类

```
局部内部类是在方法中定义的类，所以外界是无法直接使用的，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量。
```

#### int与String相互转换

* **int转换为String**
  * public static String valueOf(int i)：返回int参数的字符串形式。该方法是String类中的方法
* **String转换为int**
  * public static int parseInt(String s)：将字符串解析为int类型，该方法是Integer类中的方法

#### 异常体系

![1572435414874](C:\Users\RYQBDYQ\AppData\Local\Temp\1572435414874.png)

#### throws和throw区别

**throws**

* 用在方法后面，跟的是异常类名
* 表示抛出异常，由方法的调用者处理
* 表示出现异常的一种可能性，并不一定会发生异常

**throw**

* 用在方法体内，跟的是异常对象名
* 表示抛出异常，由方法体内的语句处理
* 执行throw一定抛出了某种异常

---

#### 2019年10月31号

#### 进程

* 进程是正在运行的程序，是系统进行资源分配和调用的独立单位。
* 每一个进程都有它自己的内存空间和系统资源。

#### 线程

* 是进程中的单个顺序控制流，是一条执行路径
* 单线程：一个进程如果只有一条执行路径，称为单线程程序
* 多线程：一个进程如果有多条执行路径，称为多线程程序

#### 多线程的实现方式

方式1：继承Thread类

* 定义一个类MyThread继承Thread类

* 在MyThread类中重写run()方法

* 创建MyThread类中的对象

* 启动线程

  * 两个小问题：

    * 为什么要重写run()方法？

      因为run()是用来封装被线程执行的代码

    * run()方法和start()方法的区别？

      run()：封装线程执行的代码，直接调用，相当于普通方法的调用

      start()：启动线程，然后由JVM调用此线程的run()方法

#### 网络编程三要素

**IP地址**

* 要想让网络中的计算机能够相互通信，必须为每一台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识

**端口**

* 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了，也就是应用程序的标识。

**协议**

* 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样，在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式，传输速率，传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换，常见的协议有UDP和TCP协议。

常用命令：

* ipconfig：查看本机IP地址
* ping IP地址：检查网络是否连通

特殊IP地址：

* 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用

#### InetAddress的使用

InetAddress：此类表示Internet协议地址

|                  方法名                   |                             说明                             |
| :---------------------------------------: | :----------------------------------------------------------: |
| static InetAddress getByName(String host) | 确定主机名称的IP地址，主机名称可以是机器名称，也可以是IP地址 |
|           String getHostName()            |                     获取此IP地址的主机名                     |
|          String getHostAddress()          |                 返回文本显示中的IP地址字符串                 |

协议：计算机网络中，连接和通信的规则被称为网络通信协议。

**UDP协议**

* 用户数据报协议（User Datagram Protocol）
* UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接，简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源较小，通信效率高，所以通常都会用于音频、视频和普通数据的传输，**在传输重要数据时不建议使用UDP协议**。

**TCP协议**

* 传输控制协议（Transmission Control Protocol）
* TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后在传输数据，它提供了两台计算机之间可靠无差错的数据传输，在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”
* 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠
  * 第一次握手，客户端向服务器端发出连接请求，等待服务器确认
  * 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求
  * 第三次握手，客户端再次向服务器端发送确认信息，确认连接
* 完成三次握手，连接建立后，客户端与服务器就可以开始进行数据传输了，由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛

#### UDP发送数据

1. 创建发送端的Socket对象（DatagramSocket）DatagramSocket()

   ```
   DatagramSocket ds = new DatagramSocket();
   ```

2. 创建数据，并把数据打包 DatagramPacket(byte[] bys,int length,InetAddress address,int port)

   ```
   byte[] bys = "hello,world".getBytes();
   int length = bys.length;
   InetAddress addr = InetAddress.getByName("172.17.24.101");
   int port = 10000;
   DatagramPacket dp = new DatagramPacket(bys,length, addr, port);
   ```

3. 调用DatagramSocket对象的方法发送数据 void send(DatagramPacket p)

   ```
   ds.send(dp);
   ```

4. 关闭发送端 void close()

   ```
   ds.close();
   ```

#### UDP接收数据

1. 创建接收端的Socket对象（DatagramSocket）

   DatagramSocket(int port)

   ```java
   DatagramSocket ds = new DatagramSocket(10000);
   ```

2. 创建一个数据包，用于接收数据

   DatagramPacket(byte[] buf,int length)

   ```java
   byte [] data = new byte[1024];
   DatagramPacket dp = new DatagramPacket(data,data.length);
   ```

3. 调用DatagramSocket对象的方法接收数据

   void receive(DatagramPacket p)

   ```java
   ds.receive(dp);
   ```

4. 解析数据包，并把数据在控制台显示

   byte[] getData()

   int getLength()

   ```java
   byte[] dpData = dp.getData();
   int len = dp.getLength();
   String s = new String(dpData,0,len);
   System.out.println(s);
   ```

5. 关闭接收端

   void close()

   ```java
   ds.close();
   ```

#### TCP发送数据

1. 创建客户端的Socket对象（Socket）

   Socket(String host,int port)

   ```
   Socket socket = new Socket("172.17.24.101",12222);
   ```

2. 获取输出流

   ```
   OutputStream outputStream = socket.getOutputStream();
   outputStream.write("hello,刘思梦,我来了".getBytes());
   ```

3. 释放资源

   ```
   socket.close();
   ```

#### TCP接收数据

1. 创建服务器端的Socket对象（ServerSocket）

   ```
   ServerSocket ss = new ServerSocket(12222);
   ```

2. 监听客户端连接，返回一个Socket对象

   ```
   Socket accept = ss.accept();
   ```

3. 获取输入流，读数据，并把数据显示在控制台中

   ```
   InputStream inputStream = accept.getInputStream();
   byte[] bys = new byte [1024];
   int len = inputStream.read(bys);
   String s = new String(bys,0,len);
   System.out.println("数据是："+s);
   ```

4. 释放资源

   ```
   accept.close();
   ss.close();
   ```

#### Lambda表达式

- 参数类型可以省略
- 但是有多个参数的情况下，要么全省略类型，要么都不省略
- 如果参数仅有一个，那么小括号可以省略
- 如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉

#### Lambda表达式注意事项

- 使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法
- 必须有上下文环境，才能推导出Lambda对应的接口
  - 根据局部变量的赋值得知Lambda对应的接口：Runnable r = () -> System.out.println(".....");
  - 根据调用方法的参数得知Lambda对应的接口：new Thread(() -> Systen.out.println(".....")).start();

#### 接口组成更新概述

- 常量
  - public static final
- 抽象方法
  - public abstract
- 默认方法（Java 8）
- 静态方法（Java 8）
- 私有方法（Java 9）

#### 接口中默认方法

接口中默认方法的定义格式：

- 格式：public **default** 返回值类型 方法名（参数列表）{   }
- 范例：public **default** void show(){    }

接口中默认方法的注意事项：

- 默认方法不是抽象方法，所以不强制被重写，但是可以重写，重写的时候要去掉default关键字
- public可以省略，default不能省略

#### 接口中静态方法

接口中静态方法的定义格式：

- 格式：public **static** 返回值类型  方法名（参数列表）{   }
- 范例：public **static** void show() {   }

接口中静态方法的注意事项：

- 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
- public 可以 省略，static不能省略

#### 接口中私有方法

接口中私有方法的定义格式：

- 格式1：private 返回值类型 方法名（参数列表）{   }
- 范例1：private void show(){   }
- 格式2：private static 返回值类型 方法名（参数列表）{   }
- 范例2：private static show() {    }

接口中私有方法的注意事项：

- 默认方法可以调用私有的静态方法或者非静态方法
- 静态方法只能调用私有的静态方法

#### 方法引用符

方法引用符

- ::该符号为引用运算符，而它所在的表达式被称为方法引用

#### 函数式接口

函数式接口：有且仅有一个抽象方法的接口

Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导

如何检测一个接口是不是函数式接口呢？

- @Functionallnterface
- 放在接口定义的上方：如果接口是函数式接口，编译通过，如果不是，编译失败

注意：

- 我们定义函数式接口的时候，@Functionallnterface是可选的，就算我不写注解，只要保证满足函数式接口定义的条件，也照样是函数式接口，但是，建议加上该注解。

---

#### 2019年11月1日

#### 1. 体验一下面试官对于消息队列的7个连环炮

#### 2. 如何进行消息队列的技术选型？

- 解耦：A系统发送个数据到BCD系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统还要时时刻刻考虑BCD系统如果挂了咋办？要不要重发？头都大了。。。。

  **不用MQ解耦的场景**

  ![不用mq解耦是的场景](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\01\图片.png)

  **使用MQ解耦的场景**

  ![使用MQ解耦的场景](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\02\04_使用MQ进行异步化之后的接口性能优化.png)

![](D:\New Journey\Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师\05_知其然而知其所以然：如何进行消息队列的技术选型？\视频\02\图片.png)

- 使用MQ的缺点
  - 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了怎么办，整个系统都宕机了
  - 系统复杂性提高：硬生生加了MQ进来，怎么保证消息没有重复消费，怎么处理消息丢失，问题一大堆
  - 一致性问题：A系统处理完了直接返回成功了，都以为请求成功了，要是BCD系统中，

 

 

 





