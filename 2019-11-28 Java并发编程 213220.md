# Java并发编程读后感

> **避免死锁的几个常见方法：**

```
1.避免一个线程同时获取多个锁
2.避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
3.尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制
4.对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。
```

```
1.对于普通同步方法，锁是当前实例对象。
2.对于静态同步方法，锁是当前类的Class对象。
3.对于同步方法块，锁是Synchonized括号里配置的对象。
```

> 偏向锁：

```
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要在测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
```

> 偏向锁的撤销

```
偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
```

> 关闭偏向锁

```
可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0
关闭偏向锁：-XX:-UseBiasedLocking=false
```

> 轻量级锁

```
（1）轻量级锁加锁
线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
（2）轻量级锁解锁
轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀称重量级锁。
```

> 锁的优缺点对比

|    锁    |                             优点                             |                      缺点                      |              适用场景              |
| :------: | :----------------------------------------------------------: | :--------------------------------------------: | :--------------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 |  适用于只有一个线程访问同步块场景  |
| 轻量级锁 |           竞争的线程不会阻塞，提高了程序的响应速度           | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 |               线程竞争不使用自旋，不会消耗CPU                |             线程阻塞，响应时间缓慢             |   追求吞吐量，同步块执行速度较长   |

> CAS实现原子操作的三大问题

```
（1）ABA问题
因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了，ABA问题的解决思路就是使用版本号，在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A->B->A就会变成1A->2B->3A。从jdk1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题，这个类的compareAndSet方法的作用是首先检查前期引用是否等于预期引用，并且检查当前标示是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
（2）循环时间长开销大
自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升，pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，他可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空，从而提高CPU的执行效率。

```

